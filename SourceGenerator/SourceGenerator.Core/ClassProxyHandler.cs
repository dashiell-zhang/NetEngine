using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using SourceGenerator.Core.Internal;

namespace SourceGenerator.Core;

internal sealed class ClassProxyHandler
{
    private const string ProxyBehaviorAttributeMetadataName = "SourceGenerator.Runtime.Attributes.ProxyBehaviorAttribute";

    public bool CanHandle(INamedTypeSymbol type, AttributeData? attribute)
        => type.TypeKind == TypeKind.Class;

    public void Execute(in HandlerContext ctx)
    {
        var src = GenerateDerivedProxy(ctx.Type);
        var hint = GetSafeHintName(ctx.Type) + ".g.cs";
        ctx.Context.AddSource(hint, src);
    }

    private static string GenerateDerivedProxy(INamedTypeSymbol cls)
    {
        var ns = cls.ContainingNamespace.IsGlobalNamespace
            ? "NetEngine.Generated"
            : cls.ContainingNamespace.ToDisplayString();

        var classDisplay = cls.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat);
        var classFull = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty);
        var proxyName = cls.Name + "_Proxy";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();


        // proxy class derives from original implementation and re-lists implemented interfaces
        // use fully-qualified names to avoid cross-namespace resolution issues
        var ifaceList = cls.AllInterfaces.Length == 0 ? string.Empty : ", " + string.Join(", ", cls.AllInterfaces.Select(i => i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)));
        sb.Append("public sealed class ").Append(proxyName).Append(" : ").Append(classDisplay).Append(ifaceList).AppendLine()
          .AppendLine("{")
          .AppendLine("    private readonly global::System.IServiceProvider? __sp;")
          .AppendLine();

        // constructors: mirror base public/protected ctors; also add overloads with IServiceProvider if not already leading
        foreach (var ctor in cls.Constructors)
        {
            if (ctor.DeclaredAccessibility != Accessibility.Public && ctor.DeclaredAccessibility != Accessibility.Protected)
                continue;

            var paramList = string.Join(", ", ctor.Parameters.Select(p => FormatParameter(p, includeDefault: true)));
            var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));
            // plain mirror
            sb.Append("    public ").Append(proxyName).Append('(').Append(paramList).Append(')').AppendLine()
              .AppendLine("        : base(" + argList + ")")
              .AppendLine("    {")
              .AppendLine("    }")
              .AppendLine();

            // IServiceProvider-leading overload if first param is not IServiceProvider
            var firstIsSp = ctor.Parameters.FirstOrDefault() is IParameterSymbol fp && IsType(fp.Type, "System.IServiceProvider");
            if (!firstIsSp)
            {
                var withSpParams = (ctor.Parameters.Length == 0)
                    ? "global::System.IServiceProvider sp"
                    : "global::System.IServiceProvider sp, " + paramList;
                sb.Append("    public ").Append(proxyName).Append('(').Append(withSpParams).Append(')').AppendLine()
                  .AppendLine("        : base(" + argList + ")")
                  .AppendLine("    {")
                  .AppendLine("        __sp = sp;")
                  .AppendLine("    }")
                  .AppendLine();
            }
        }

        // override virtual/abstract public instance methods
        foreach (var method in cls.GetMembers().OfType<IMethodSymbol>())
        {
            if (method.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise or MethodKind.StaticConstructor or MethodKind.Constructor)
                continue;
            if (method.DeclaredAccessibility != Accessibility.Public || method.IsStatic)
                continue;
            // skip by-ref returns which cannot be proxied safely
            if (method.ReturnsByRef || method.ReturnsByRefReadonly)
                continue;
            if (!(method.IsVirtual || method.IsAbstract || method.IsOverride))
                continue;
            AppendDerivedOverride(sb, method, classFull, callTarget: "base");
        }

        // explicit interface implementations to intercept when used via interface
        foreach (var iface in cls.AllInterfaces)
        {
            foreach (var member in iface.GetMembers())
            {
                switch (member)
                {
                    case IMethodSymbol m:
                        if (m.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise)
                            continue;
                        // skip by-ref return interface members
                        if (m.ReturnsByRef || m.ReturnsByRefReadonly) continue;
                        // find implementation in class
                        var impl = cls.FindImplementationForInterfaceMember(m) as IMethodSymbol;
                        AppendExplicitInterfaceMethod(sb, iface, m, impl, classFull);
                        break;
                    case IPropertySymbol p:
                        AppendExplicitInterfaceProperty(sb, iface, p);
                        break;
                    case IEventSymbol e:
                        AppendExplicitInterfaceEvent(sb, iface, e);
                        break;
                }
            }
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void AppendDerivedOverride(StringBuilder sb, IMethodSymbol method, string typeFullName, string callTarget)
    {
        var isGenericTask = method.ReturnType is INamedTypeSymbol nts && nts.IsGenericType && IsType(nts.ConstructedFrom, "System.Threading.Tasks.Task");
        var isTask = method.ReturnType is INamedTypeSymbol nts0 && !nts0.IsGenericType && IsType(nts0, "System.Threading.Tasks.Task");
        var isGenericValueTask = method.ReturnType is INamedTypeSymbol nts2 && nts2.IsGenericType && IsType(nts2.ConstructedFrom, "System.Threading.Tasks.ValueTask");
        var isValueTask = method.ReturnType is INamedTypeSymbol nts3 && !nts3.IsGenericType && IsType(nts3, "System.Threading.Tasks.ValueTask");

        var returnType = method.ReturnType
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var methodName = method.Name;
        var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
        var paramList = string.Join(", ", method.Parameters.Select(p => FormatParameter(p, includeDefault: false)));
        var argList = string.Join(", ", method.Parameters.Select(p => (p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty) + p.Name));

        sb.Append("    public override ").Append(returnType).Append(' ').Append(methodName).Append(typeParams)
          .Append('(').Append(paramList).Append(')').AppendLine()
          .AppendLine("    {");

        if (method.Parameters.Length > 0)
        {
            sb.AppendLine("        var __argsDict = new global::System.Collections.Generic.Dictionary<string, object?>(" + method.Parameters.Length + ");");
            foreach (var p in method.Parameters)
            {
                var isOut = p.RefKind == RefKind.Out;
                sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = ").Append(isOut ? "null" : p.Name).AppendLine(";");
            }
            sb.AppendLine("        var __args = global::SourceGenerator.Runtime.JsonUtil.ToJson(__argsDict);");
            sb.AppendLine("        object? __argsObj = __argsDict;");
        }
        else
        {
            sb.AppendLine("        string? __args = null;");
            sb.AppendLine("        object? __argsObj = null;");
        }

        sb.AppendLine("        var __logMethod = \"" + typeFullName + "\" + \"." + methodName + "\";");
        sb.AppendLine("        var __logger = (__sp?.GetService(typeof(global::Microsoft.Extensions.Logging.ILoggerFactory)) as global::Microsoft.Extensions.Logging.ILoggerFactory)?.CreateLogger(\"SourceGenerator.Runtime.ProxyRuntime\");");

        var hasByRef = method.Parameters.Any(p => p.RefKind != RefKind.None);
        var behaviorSnippets = new List<string> { "new global::SourceGenerator.Runtime.Pipeline.Behaviors.LoggingBehavior()" };
        var optionsSetters = new List<string>();
        foreach (var a in method.GetAttributes())
        {
            if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
            {
                var include = !hasByRef || CanUseAsFilter(a);
                if (include)
                {
                    behaviorSnippets.Add($"new {behaviorFull}()");
                    if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                }
            }
        }
        sb.AppendLine("        var __behaviors = new global::SourceGenerator.Runtime.Pipeline.IInvocationAsyncBehavior[] { " + string.Join(", ", behaviorSnippets) + " };");
        var __hasReturn = isGenericTask || isGenericValueTask || (!isTask && !isValueTask && !method.ReturnsVoid);
        sb.AppendLine("        var __ctx = new global::SourceGenerator.Runtime.Pipeline.InvocationContext { Method = __logMethod, ArgsJson = __args, Args = __argsObj, TraceId = global::System.Guid.CreateVersion7(), Log = true, HasReturnValue = " + (__hasReturn ? "true" : "false") + ", ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
        if (optionsSetters.Count > 0) sb.AppendLine("        " + string.Join("\n        ", optionsSetters));

        if (hasByRef)
        {
            sb.AppendLine("        var __filters = new global::System.Collections.Generic.List<global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior>();");
            sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior __f) __filters.Add(__f); }");
            if (isTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __t = {callTarget}.{methodName}{typeParams}({argList});");
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        return __t.ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); });");
            }
            else if (isGenericTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __t = {callTarget}.{methodName}{typeParams}({argList});");
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        return __t.ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } var __res = __task.Result; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __res); return __res; });");
            }
            else if (isValueTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __vt = {callTarget}.{methodName}{typeParams}({argList});");
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        return new global::System.Threading.Tasks.ValueTask( __vt.AsTask().ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); }) );");
            }
            else if (isGenericValueTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __vt = {callTarget}.{methodName}{typeParams}({argList});");
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        return new global::System.Threading.Tasks.ValueTask<" + ((INamedTypeSymbol)method.ReturnType).TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)) + ">( __vt.AsTask().ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } var __res = __task.Result; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __res); return __res; }) );");
            }
            else if (method.ReturnsVoid)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); " + callTarget + "." + methodName + typeParams + "(" + argList + "); " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("        return;");
            }
            else
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); var __ret = " + callTarget + "." + methodName + typeParams + "(" + argList + "); " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __ret); return __ret; } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
            }
        }
        else
        {
            var runtime = "global::SourceGenerator.Runtime.ProxyRuntime";
            if (isTask)
            {
                sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
            }
            else if (isGenericTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => new global::System.Threading.Tasks.ValueTask<{tArg}>( {callTarget}.{methodName}{typeParams}({argList}) ) ).AsTask();");
            }
            else if (isValueTask)
            {
                sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask( {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}).AsTask()) );");
            }
            else if (isGenericValueTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask<{tArg}>( {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}) ).AsTask() );");
            }
            else if (method.ReturnsVoid)
            {
                sb.AppendLine($"        {runtime}.Execute<object?>(__ctx, () => {{ {callTarget}.{methodName}{typeParams}({argList}); return global::System.Threading.Tasks.ValueTask.FromResult<object?>(null); }});");
                sb.AppendLine("        return;");
            }
            else
            {
                sb.AppendLine($"        return {runtime}.Execute<{returnType}>(__ctx, () => global::System.Threading.Tasks.ValueTask.FromResult({callTarget}.{methodName}{typeParams}({argList})));");
            }
        }

        sb.AppendLine("    }");
    }

    private static void AppendExplicitInterfaceMethod(StringBuilder sb, INamedTypeSymbol iface, IMethodSymbol method, IMethodSymbol? impl, string typeFullName)
    {
        // Build compile-time behaviors from both interface method and implementation method attributes
        var isGenericTask = method.ReturnType is INamedTypeSymbol nts && nts.IsGenericType && IsType(nts.ConstructedFrom, "System.Threading.Tasks.Task");
        var isTask = method.ReturnType is INamedTypeSymbol nts0 && !nts0.IsGenericType && IsType(nts0, "System.Threading.Tasks.Task");
        var isGenericValueTask = method.ReturnType is INamedTypeSymbol nts2 && nts2.IsGenericType && IsType(nts2.ConstructedFrom, "System.Threading.Tasks.ValueTask");
        var isValueTask = method.ReturnType is INamedTypeSymbol nts3 && !nts3.IsGenericType && IsType(nts3, "System.Threading.Tasks.ValueTask");

        var returnType = method.ReturnType
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var ifaceDisplay = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = method.Name;
        var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
        var paramList = string.Join(", ", method.Parameters.Select(p => FormatParameter(p, includeDefault: false)));
        var argList = string.Join(", ", method.Parameters.Select(p => (p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty) + p.Name));

        sb.Append("    ").Append(returnType).Append(' ').Append(ifaceDisplay).Append('.').Append(methodName).Append(typeParams)
          .Append('(').Append(paramList).Append(')').AppendLine()
          .AppendLine("    {");

        if (method.Parameters.Length > 0)
        {
            sb.AppendLine("        var __argsDict = new global::System.Collections.Generic.Dictionary<string, object?>(" + method.Parameters.Length + ");");
            foreach (var p in method.Parameters)
            {
                var isOut = p.RefKind == RefKind.Out;
                sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = ").Append(isOut ? "null" : p.Name).AppendLine(";");
            }
            sb.AppendLine("        var __args = global::SourceGenerator.Runtime.JsonUtil.ToJson(__argsDict);");
            sb.AppendLine("        object? __argsObj = __argsDict;");
        }
        else
        {
            sb.AppendLine("        string? __args = null;");
            sb.AppendLine("        object? __argsObj = null;");
        }

        sb.AppendLine("        var __logMethod = \"" + typeFullName + "\" + \"." + methodName + "\";");
        sb.AppendLine("        var __logger = (__sp?.GetService(typeof(global::Microsoft.Extensions.Logging.ILoggerFactory)) as global::Microsoft.Extensions.Logging.ILoggerFactory)?.CreateLogger(\"SourceGenerator.Runtime.ProxyRuntime\");");

        var hasByRef2 = method.Parameters.Any(p => p.RefKind != RefKind.None);
        var behaviorSnippets = new List<string> { "new global::SourceGenerator.Runtime.Pipeline.Behaviors.LoggingBehavior()" };
        var optionsSetters = new List<string>();
        foreach (var a in method.GetAttributes())
        {
            if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
            {
                var include = !hasByRef2 || CanUseAsFilter(a);
                if (include)
                {
                    behaviorSnippets.Add($"new {behaviorFull}()");
                    if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                }
            }
        }
        if (impl is not null)
        {
            foreach (var a in impl.GetAttributes())
            {
                if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
                {
                    var include = !hasByRef2 || CanUseAsFilter(a);
                    if (include)
                    {
                        behaviorSnippets.Add($"new {behaviorFull}()");
                        if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                    }
                }
            }
        }
        sb.AppendLine("        var __behaviors = new global::SourceGenerator.Runtime.Pipeline.IInvocationAsyncBehavior[] { " + string.Join(", ", behaviorSnippets) + " };");
        var __hasReturn = isGenericTask || isGenericValueTask || (!isTask && !isValueTask && !method.ReturnsVoid);
        sb.AppendLine("        var __ctx = new global::SourceGenerator.Runtime.Pipeline.InvocationContext { Method = __logMethod, ArgsJson = __args, Args = __argsObj, TraceId = global::System.Guid.CreateVersion7(), Log = true, HasReturnValue = " + (__hasReturn ? "true" : "false") + ", ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
        if (optionsSetters.Count > 0) sb.AppendLine("        " + string.Join("\n        ", optionsSetters));

        var call = "base." + methodName + typeParams + "(" + argList + ")";
        if (hasByRef2)
        {
            sb.AppendLine("        var __filters = new global::System.Collections.Generic.List<global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior>();");
            sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior __f) __filters.Add(__f); }");
            if (isTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __t = {call};");
                sb.AppendLine("        var __update = \"" + BuildArgsUpdateSnippet(method) + "\";");
                sb.AppendLine("        return __t.ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } " + BuildArgsUpdateSnippet(method) + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); });");
            }
            else if (isGenericTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __t = {call};");
                sb.AppendLine("        return __t.ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } var __res = __task.Result; " + BuildArgsUpdateSnippet(method) + " foreach (var __f in __filters) __f.OnAfter(__ctx, __res); return __res; });");
            }
            else if (isValueTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __vt = {call};");
                sb.AppendLine("        return new global::System.Threading.Tasks.ValueTask( __vt.AsTask().ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } " + BuildArgsUpdateSnippet(method) + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); }) );");
            }
            else if (isGenericValueTask)
            {
                sb.AppendLine("        foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"        var __vt = {call};");
                sb.AppendLine("        return new global::System.Threading.Tasks.ValueTask<" + ((INamedTypeSymbol)method.ReturnType).TypeArguments[0].ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)) + ">( __vt.AsTask().ContinueWith(__task => { if (__task.IsFaulted) { var __ex = __task.Exception?.InnerException ?? __task.Exception!; foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw __ex; } var __res = __task.Result; " + BuildArgsUpdateSnippet(method) + " foreach (var __f in __filters) __f.OnAfter(__ctx, __res); return __res; }) );");
            }
            else if (method.ReturnsVoid)
            {
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); " + call + "; " + BuildArgsUpdateSnippet(method) + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("        return;");
            }
            else
            {
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); var __ret = " + call + "; " + BuildArgsUpdateSnippet(method) + " foreach (var __f in __filters) __f.OnAfter(__ctx, __ret); return __ret; } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
            }
        }
        else
        {
            var runtime = "global::SourceGenerator.Runtime.ProxyRuntime";
            if (isTask)
            {
                sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
            }
            else if (isGenericTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => new global::System.Threading.Tasks.ValueTask<{tArg}>( {call} ) ).AsTask();");
            }
            else if (isValueTask)
            {
                sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask( {runtime}.ExecuteTask(__ctx, () => {call}.AsTask()) );");
            }
            else if (isGenericValueTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask<{tArg}>( {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {call} ).AsTask() );");
            }
            else if (method.ReturnsVoid)
            {
                sb.AppendLine($"        {runtime}.Execute<object?>(__ctx, () => {{ {call}; return global::System.Threading.Tasks.ValueTask.FromResult<object?>(null); }});");
                sb.AppendLine("        return;");
            }
            else
            {
                sb.AppendLine($"        return {runtime}.Execute<{returnType}>(__ctx, () => global::System.Threading.Tasks.ValueTask.FromResult({call}));");
            }
        }

        sb.AppendLine("    }");
    }

    private static void AppendExplicitInterfaceProperty(StringBuilder sb, INamedTypeSymbol iface, IPropertySymbol prop)
    {
        var typeName = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var ifaceDisplay = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        sb.Append("    ").Append(typeName).Append(' ').Append(ifaceDisplay).Append('.').Append(prop.Name).AppendLine()
          .AppendLine("    {");
        if (prop.GetMethod is not null)
        {
            sb.AppendLine("        get => base." + prop.Name + ";");
        }
        if (prop.SetMethod is not null)
        {
            sb.AppendLine("        set => base." + prop.Name + " = value;");
        }
        sb.AppendLine("    }");
    }

    private static void AppendExplicitInterfaceEvent(StringBuilder sb, INamedTypeSymbol iface, IEventSymbol ev)
    {
        var typeName = ev.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var ifaceDisplay = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        sb.Append("    event ").Append(typeName).Append(' ').Append(ifaceDisplay).Append('.').Append(ev.Name).AppendLine()
          .AppendLine("    {")
          .AppendLine("        add => base." + ev.Name + " += value;")
          .AppendLine("        remove => base." + ev.Name + " -= value;")
          .AppendLine("    }");
    }

    private static bool TryGetBehaviorSpec(AttributeData a, out string behaviorFull, out string? optSetter)
    {
        behaviorFull = string.Empty;
        optSetter = null;
        var attrClass = a.AttributeClass as INamedTypeSymbol;
        if (attrClass is null) return false;
        INamedTypeSymbol? proxyBase = null;
        for (var t = attrClass; t is not null; t = t.BaseType as INamedTypeSymbol)
        {
            var constructed = t.ConstructedFrom ?? t;
            var fullName = constructed.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fullName.Contains(ProxyBehaviorAttributeMetadataName, StringComparison.Ordinal)) { proxyBase = t; break; }
        }
        if (proxyBase is null) return false;
        ITypeSymbol? behaviorTypeSymbol = null;
        INamedTypeSymbol? optionsTypeSymbol = null;
        if (proxyBase.IsGenericType)
        {
            if (proxyBase.TypeArguments.Length == 1)
            {
                behaviorTypeSymbol = proxyBase.TypeArguments[0];
            }
            else if (proxyBase.TypeArguments.Length == 2)
            {
                behaviorTypeSymbol = proxyBase.TypeArguments[0];
                optionsTypeSymbol = proxyBase.TypeArguments[1] as INamedTypeSymbol;
            }
        }
        if (behaviorTypeSymbol is null) return false;
        behaviorFull = behaviorTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (optionsTypeSymbol is not null)
        {
            var assigns = new List<string>();
            foreach (var kv in a.NamedArguments)
            {
                var propName = kv.Key;
                var prop = optionsTypeSymbol.GetMembers().OfType<IPropertySymbol>().FirstOrDefault(p => p.Name == propName && !p.IsReadOnly);
                if (prop is null) continue;
                var lit = ToCSharpLiteral(kv.Value);
                if (lit is null) continue;
                assigns.Add(propName + " = " + lit);
            }
            var optFull = optionsTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var init = assigns.Count > 0 ? " { " + string.Join(", ", assigns) + " }" : string.Empty;
            optSetter = $"__ctx.SetFeature(new {optFull}{init});";
        }
        return true;
    }

    private static bool CanUseAsFilter(AttributeData a)
    {
        // Try to determine if the behavior type implements IInvocationBehavior (sync filter) so it can participate in by-ref sync path
        var attrClass = a.AttributeClass as INamedTypeSymbol;
        if (attrClass is null) return false;
        INamedTypeSymbol? proxyBase = null;
        for (var t = attrClass; t is not null; t = t.BaseType as INamedTypeSymbol)
        {
            var constructed = t.ConstructedFrom ?? t;
            var fullName = constructed.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (fullName.Contains(ProxyBehaviorAttributeMetadataName, StringComparison.Ordinal)) { proxyBase = t; break; }
        }
        if (proxyBase is null) return false;
        ITypeSymbol? behaviorTypeSymbol = null;
        if (proxyBase.IsGenericType && proxyBase.TypeArguments.Length >= 1)
        {
            behaviorTypeSymbol = proxyBase.TypeArguments[0];
        }
        if (behaviorTypeSymbol is INamedTypeSymbol nts)
        {
            foreach (var itf in nts.AllInterfaces)
            {
                var name = itf.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (name == "global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior" || name.EndsWith("SourceGenerator.Runtime.IInvocationBehavior", StringComparison.Ordinal))
                    return true;
            }
        }
        return false;
    }

    private static string FormatParameter(IParameterSymbol p, bool includeDefault)
    {
        var type = p.Type
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var mod = p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty;
        string @default = string.Empty;
        if (includeDefault && p.HasExplicitDefaultValue)
        {
            if (p.ExplicitDefaultValue is null)
            {
                @default = p.Type.IsReferenceType ? " = null" : " = default";
            }
            else if (p.ExplicitDefaultValue is string s)
            {
                @default = " = \"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"";
            }
            else if (p.ExplicitDefaultValue is bool b)
            {
                @default = b ? " = true" : " = false";
            }
            else if (p.ExplicitDefaultValue is char ch)
            {
                var esc = ch == '\'' ? "\\'" : ch.ToString();
                @default = " = '" + esc + "'";
            }
            else if (p.ExplicitDefaultValue is IFormattable f)
            {
                @default = " = " + f.ToString(null, System.Globalization.CultureInfo.InvariantCulture);
            }
            else
            {
                @default = " = " + p.ExplicitDefaultValue.ToString();
            }
        }
        return mod + type + " " + p.Name + @default;
    }

    private static bool IsType(ITypeSymbol t, string metadataName)
        => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Contains(metadataName, StringComparison.Ordinal);

    private static string BuildArgsUpdateSnippet(IMethodSymbol method)
    {
        var updates = new List<string>();
        foreach (var p in method.Parameters)
        {
            if (p.RefKind != RefKind.None)
            {
                updates.Add($"__argsDict[\"{p.Name}\"] = {p.Name};");
            }
        }
        return updates.Count == 0 ? string.Empty : string.Join(" ", updates);
    }

    private static string? ToCSharpLiteral(TypedConstant c)
    {
        if (c.IsNull) return "null";
        if (c.Value is null) return null;
        if (c.Value is string s) return "\"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"";
        if (c.Value is bool b) return b ? "true" : "false";
        if (c.Value is char ch) return "'" + (ch == '\'' ? "\\'" : ch.ToString()) + "'";
        if (c.Type is INamedTypeSymbol nts && nts.TypeKind == TypeKind.Enum)
        {
            var named = nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return named + "." + c.Value.ToString();
        }
        if (c.Value is IFormattable f) return f.ToString(null, System.Globalization.CultureInfo.InvariantCulture);
        return c.Value?.ToString();
    }

    private static string GetSafeHintName(INamedTypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace ? "global" : type.ContainingNamespace.ToDisplayString().Replace('.', '_');
        return ns + "__" + type.Name + "+Proxy";
    }
}

