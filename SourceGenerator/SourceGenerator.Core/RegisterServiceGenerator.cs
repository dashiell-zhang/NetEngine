using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator.Core;

/// <summary>
/// 根据 RegisterServiceAttribute 生成 DI 注册扩展方法。
/// 每个项目独立生成一份。
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class RegisterServiceGenerator : IIncrementalGenerator
{
    private const string RegisterServiceAttributeMetadataName = "SourceGenerator.Runtime.Attributes.RegisterServiceAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider.ForAttributeWithMetadataName(
            RegisterServiceAttributeMetadataName,
            static (node, _) => node is ClassDeclarationSyntax,
            static (syntaxContext, _) => syntaxContext
        );

        // 收集本次编译中所有 [RegisterService] 目标
        var collected = candidates.Collect().Combine(context.CompilationProvider);

        context.RegisterSourceOutput(collected, static (spc, tuple) =>
        {
            var (attrContexts, compilation) = (tuple.Left, tuple.Right);

            var registrations = new StringBuilder();

            foreach (var ctx in attrContexts)
            {
                if (ctx.TargetSymbol is not INamedTypeSymbol typeSymbol)
                    continue;

                // 只处理当前项目源码中的类型，避免跨项目“公共库”被自动注册
                if (!typeSymbol.Locations.Any(l => l.IsInSource))
                    continue;

                var attrData = ctx.Attributes.FirstOrDefault(a =>
                    a.AttributeClass?.ToDisplayString() == RegisterServiceAttributeMetadataName);

                if (attrData is null)
                    continue;

                if (typeSymbol.TypeKind != TypeKind.Class || typeSymbol.IsAbstract)
                    continue;

                var servicesSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.DependencyInjection.IServiceCollection");
                if (servicesSymbol is null)
                    return;

                var lifetime = GetLifetime(attrData) ?? "Transient";
                var keyExpr = GetKeyExpression(attrData);

                var iface = typeSymbol.AllInterfaces.FirstOrDefault();
                var typeDisplay = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var ifaceDisplay = iface?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                var call = BuildRegistrationCall(lifetime, keyExpr, ifaceDisplay, typeDisplay);
                registrations.Append("        ").AppendLine(call);
            }

            if (registrations.Length == 0)
                return;

            var assemblyName = compilation.AssemblyName ?? "Assembly";
            var safeAssemblyName = SanitizeIdentifier(assemblyName);
            // 命名空间统一为 NetEngine.Generated，通过不同的方法名区分不同程序集：
            // Add{AssemblyName}RegisterServices
            var ns = "NetEngine.Generated";
            var extClassName = "ServiceCollectionExtensions";
            var methodName = "Add" + safeAssemblyName + "RegisterServices";

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();

            sb.Append("public static partial class ").Append(extClassName).AppendLine();
            sb.AppendLine("{");
            sb.Append("    public static Microsoft.Extensions.DependencyInjection.IServiceCollection ")
              .Append(methodName)
              .AppendLine("(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
            sb.AppendLine("    {");
            sb.Append(registrations);
            sb.AppendLine("        return services;");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            var hintName = $"{extClassName}_RegisterServices.g.cs";
            spc.AddSource(hintName, sb.ToString());
        });
    }

    private static string BuildRegistrationCall(string lifetime, string? keyExpr, string? ifaceDisplay, string implDisplay)
    {
        var hasInterface = !string.IsNullOrWhiteSpace(ifaceDisplay);
        var hasKey = !string.IsNullOrWhiteSpace(keyExpr);

        var sb = new StringBuilder("global::Microsoft.Extensions.DependencyInjection.");

        if (!hasKey)
        {
            sb.Append(lifetime switch
            {
                "Singleton" => "ServiceCollectionServiceExtensions.AddSingleton",
                "Scoped" => "ServiceCollectionServiceExtensions.AddScoped",
                _ => "ServiceCollectionServiceExtensions.AddTransient"
            });

            if (hasInterface)
            {
                sb.Append("<").Append(ifaceDisplay).Append(", ").Append(implDisplay).Append(">(services);");
            }
            else
            {
                sb.Append("<").Append(implDisplay).Append(">(services);");
            }
        }
        else
        {
            sb.Append(lifetime switch
            {
                "Singleton" => "KeyedServiceCollectionExtensions.AddKeyedSingleton",
                "Scoped" => "KeyedServiceCollectionExtensions.AddKeyedScoped",
                _ => "KeyedServiceCollectionExtensions.AddKeyedTransient"
            });

            if (hasInterface)
            {
                sb.Append("<").Append(ifaceDisplay).Append(">(services, ").Append(keyExpr).Append(", typeof(").Append(implDisplay).Append("));");
            }
            else
            {
                sb.Append("<").Append(implDisplay).Append(">(services, ").Append(keyExpr).Append(");");
            }
        }

        return sb.ToString();
    }

    private static string? GetLifetime(AttributeData attr)
    {
        foreach (var pair in attr.NamedArguments)
        {
            var key = pair.Key;
            var value = pair.Value;

            if (key == "Lifetime" && value.Value is int enumValue)
            {
                // ServiceLifetime enum: 0 Singleton, 1 Scoped, 2 Transient
                return enumValue switch
                {
                    0 => "Singleton",
                    1 => "Scoped",
                    _ => "Transient"
                };
            }
        }

        return null;
    }

    private static string? GetKeyExpression(AttributeData attr)
    {
        foreach (var pair in attr.NamedArguments)
        {
            var key = pair.Key;
            var value = pair.Value;

            if (key == "Key")
            {
                if (value.Value is null)
                    return null;

                return value.Value switch
                {
                    string s => SymbolDisplay.FormatPrimitive(s, quoteStrings: true, useHexadecimalNumbers: false),
                    int i => i.ToString(),
                    long l => l.ToString(),
                    _ => null
                };
            }
        }

        return null;
    }

    private static string SanitizeIdentifier(string name)
    {
        var builder = new StringBuilder(name.Length);
        if (name.Length == 0)
            return "_";

        if (!SyntaxFacts.IsIdentifierStartCharacter(name[0]))
        {
            builder.Append('_');
        }

        foreach (var ch in name)
        {
            builder.Append(SyntaxFacts.IsIdentifierPartCharacter(ch) ? ch : '_');
        }

        return builder.ToString();
    }
}
