using Microsoft.Extensions.Logging;
using System.Diagnostics;namespace SourceGenerator.Runtime;public sealed class LoggingBehavior : IInvocationBehavior{    public async ValueTask<T> InvokeAsync<T>(InvocationContext ctx, Func<ValueTask<T>> next)    {        var logger = ctx.Logger;        Stopwatch? sw = null;        if (ctx.Log)        {            if (!string.IsNullOrEmpty(ctx.ArgsJson)) logger?.LogInformation($"[Proxy] Executing {ctx.Method} args: {ctx.ArgsJson}");            else logger?.LogInformation($"[Proxy] Executing {ctx.Method}");        }        if (ctx.Measure) sw = Stopwatch.StartNew();        var result = await next();        if (ctx.Measure && sw is not null)        {            sw.Stop();            logger?.LogInformation($"[Proxy] Executed {ctx.Method} in {sw.ElapsedMilliseconds}ms");        }        if (ctx.Log && typeof(T) != typeof(Unit))        {            var json = JsonUtil.ToJson(result);            logger?.LogInformation($"[Proxy] Return {ctx.Method} = {json}");        }        return result;    }}