using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SourceGenerator.Core;

/// <summary>
/// 根据 AutoProxy 特性为目标类型生成派生代理类 支持拦截调用并注入行为管道
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class AutoProxyGenerator : IIncrementalGenerator
{

    private const string AutoProxyAttributeMetadataName = "SourceGenerator.Runtime.Attributes.AutoProxyAttribute";


    /// <summary>
    /// 配置增量生成管道 注册对标记 AutoProxy 特性的类型的处理逻辑
    /// </summary>
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider.ForAttributeWithMetadataName(
            AutoProxyAttributeMetadataName,
            static (node, _) => node is ClassDeclarationSyntax,
            static (syntaxContext, _) => syntaxContext
        );

        var combined = candidates.Combine(context.CompilationProvider);

        context.RegisterSourceOutput(combined, static (spc, tuple) =>
        {
            var (ctx, compilation) = (tuple.Left, tuple.Right);
            if (ctx.TargetSymbol is not INamedTypeSymbol typeSymbol)
                return;

            var attrData = ctx.Attributes.FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == AutoProxyAttributeMetadataName);

            if (typeSymbol.TypeKind == TypeKind.Class)
            {
                var classHandler = new ClassProxyHandler();

                if (classHandler.CanHandle(typeSymbol, attrData))
                {
                    classHandler.Execute(new HandlerContext(spc, typeSymbol, attrData));
                }
            }
        });
    }


    /// <summary>
    /// 处理器执行上下文 保存生成时的编译上下文 目标类型及相关特性信息
    /// </summary>
    private readonly struct HandlerContext
    {
        public SourceProductionContext Context { get; }

        public INamedTypeSymbol Type { get; }

        public AttributeData? Attribute { get; }


        public HandlerContext(SourceProductionContext context, INamedTypeSymbol type, AttributeData? attribute)
        {
            Context = context;
            Type = type;
            Attribute = attribute;
        }
    }


    /// <summary>
    /// 针对类类型的代理生成处理器 负责生成派生代理类源码
    /// </summary>
    private sealed class ClassProxyHandler
    {

        private const string ProxyBehaviorAttributeMetadataName = "SourceGenerator.Runtime.Attributes.ProxyBehaviorAttribute";


        /// <summary>
        /// 判断当前处理器是否可以处理给定类型
        /// </summary>
        public bool CanHandle(INamedTypeSymbol type, AttributeData? attribute)
            => type.TypeKind == TypeKind.Class
               && type.Constructors.Any(c => c.DeclaredAccessibility == Accessibility.Public);


        /// <summary>
        /// 执行代理生成逻辑 并将生成结果输出到编译上下文
        /// </summary>
        public void Execute(in HandlerContext ctx)
        {
            var src = GenerateDerivedProxy(ctx.Type);
            var hint = GetSafeHintName(ctx.Type) + ".g.cs";
            ctx.Context.AddSource(hint, src);
        }


        /// <summary>
        /// 为指定类生成派生代理类的完整源码
        /// </summary>
        private static string GenerateDerivedProxy(INamedTypeSymbol cls)
        {
            var ns = cls.ContainingNamespace.IsGlobalNamespace
                ? "NetEngine.Generated"
                : cls.ContainingNamespace.ToDisplayString();

            // 使用包含和不包含 global:: 前缀的完全限定类型名
            var classFull = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty);
            var classLocal = TrimCurrentNamespace(classFull, ns);
            var proxyName = cls.Name + "_Proxy";
            var typeParamsDecl = BuildTypeParametersDecl(cls);
            var typeParamConstraints = BuildTypeParameterConstraints(cls);

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.AppendLine("using Microsoft.Extensions.Logging;");
            sb.AppendLine("using System;");
            sb.AppendLine("using System.Collections.Generic;");
            sb.AppendLine("using System.Threading.Tasks;");
            sb.AppendLine("using SourceGenerator.Runtime;");
            sb.AppendLine("using SourceGenerator.Runtime.Pipeline;");
            sb.AppendLine("using SourceGenerator.Runtime.Pipeline.Behaviors;");
            sb.AppendLine("using SourceGenerator.Runtime.Options;");
            sb.AppendLine();
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();


            // 代理类继承原始实现类型 只列出需要在代理中显式实现的接口
            var minimalInterfaces = GetInterfacesNeedingExplicitImplementations(cls);
            var ifaceList = minimalInterfaces.Length == 0 ? string.Empty : ", " + string.Join(", ", minimalInterfaces.Select(i => TrimCurrentNamespace(i, ns)));
            
            // 使用完全限定的基类类型 避免全局命名空间或嵌套类型的解析问题
            sb.Append("public sealed class ").Append(proxyName).Append(typeParamsDecl).Append(" : ").Append(classLocal).Append(ifaceList).AppendLine();
            
            if (!string.IsNullOrWhiteSpace(typeParamConstraints)) sb.Append(typeParamConstraints);
            
            sb.AppendLine("{")
              .AppendLine("    private readonly IServiceProvider? __sp;")
              .AppendLine();

            // 构造函数生成规则 镜像基类公开构造函数 并在必要时添加以 IServiceProvider 开头的重载
            foreach (var ctor in cls.Constructors)
            {
                // 仅支持适合依赖注入的 public 构造函数
                if (ctor.DeclaredAccessibility != Accessibility.Public)
                    continue;

                var paramList = string.Join(", ", ctor.Parameters.Select(p => FormatParameter(p, includeDefault: true, ns)));
                var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));
                
                // 纯粹镜像基类构造函数
                sb.Append("    public ").Append(proxyName).Append('(').Append(paramList).Append(')').AppendLine()
                  .AppendLine("        : base(" + argList + ")")
                  .AppendLine("    {")
                  .AppendLine("    }")
                  .AppendLine();

                // 如果第一个参数不是 IServiceProvider 则生成以 IServiceProvider 作为首参的重载构造函数
                var firstIsSp = ctor.Parameters.FirstOrDefault() is IParameterSymbol fp && IsType(fp.Type, "System.IServiceProvider");
                
                if (!firstIsSp)
                {
                    var withSpParams = (ctor.Parameters.Length == 0)
                        ? "IServiceProvider sp"
                        : "IServiceProvider sp, " + paramList;
                    
                    sb.Append("    public ").Append(proxyName).Append('(').Append(withSpParams).Append(')').AppendLine()
                      .AppendLine("        : base(" + argList + ")")
                      .AppendLine("    {")
                      .AppendLine("        __sp = sp;")
                      .AppendLine("    }")
                      .AppendLine();
                }
            }

            // 为虚方法 抽象方法和已重写的公开实例方法生成重写实现
            foreach (var method in cls.GetMembers().OfType<IMethodSymbol>())
            {
                if (method.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise or MethodKind.StaticConstructor or MethodKind.Constructor)
                    continue;
                
                if (method.DeclaredAccessibility != Accessibility.Public || method.IsStatic)
                    continue;
                
                if (!(method.IsVirtual || method.IsAbstract || method.IsOverride))
                    continue;
                
                AppendDerivedOverride(sb, method, classFull, callTarget: "base", ns);
            }

            // 为接口成员生成显式实现 使通过接口调用时也能被拦截
            foreach (var iface in cls.AllInterfaces)
            {
                foreach (var member in iface.GetMembers())
                {
                    switch (member)
                    {
                        case IMethodSymbol m:
                            if (m.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise)
                                continue;
                            // 在当前类层次结构中查找此接口成员的实现
                            var impl = cls.FindImplementationForInterfaceMember(m) as IMethodSymbol;
                            // 如果在继承层次中实现是显式接口实现
                            // 无法通过 base.Method(...) 转发 否则会产生编译错误
                            // 因此跳过生成对应代码
                            if (impl is not null && impl.ExplicitInterfaceImplementations.Length > 0)
                                break;
                            // 如果实现方法本身已可被重写 通过 override 路径在接口调用时也能被拦截
                            // 此时再生成显式接口实现是冗余的 为避免重复列出接口选择跳过
                            if (impl is not null && (impl.IsVirtual || impl.IsAbstract || impl.IsOverride))
                                break;
                            AppendExplicitInterfaceMethod(sb, iface, m, impl, classFull, ns);
                            break;
                        
                        case IPropertySymbol p:
                            {
                                var implProp = cls.FindImplementationForInterfaceMember(p) as IPropertySymbol;
                                if (implProp is not null && implProp.ExplicitInterfaceImplementations.Length > 0)
                                    break;
                                // 如果任一访问器可被重写 则通过 override 路径即可满足需求
                                if (implProp is not null)
                                {
                                    var gm = implProp.GetMethod; var sm = implProp.SetMethod;
                                    if ((gm is not null && (gm.IsVirtual || gm.IsAbstract || gm.IsOverride)) ||
                                        (sm is not null && (sm.IsVirtual || sm.IsAbstract || sm.IsOverride)))
                                        break;
                                }
                                AppendExplicitInterfaceProperty(sb, iface, p, cls, ns);
                            }
                            break;
                        
                        case IEventSymbol e:
                            {
                                var implEv = cls.FindImplementationForInterfaceMember(e) as IEventSymbol;
                                if (implEv is not null && implEv.ExplicitInterfaceImplementations.Length > 0)
                                    break;
                                // 如果 Add 或 Remove 访问器可被重写 则仅依赖 override 路径即可
                                if (implEv is not null)
                                {
                                    var am = implEv.AddMethod; var rm = implEv.RemoveMethod;
                                    if ((am is not null && (am.IsVirtual || am.IsAbstract || am.IsOverride)) ||
                                        (rm is not null && (rm.IsVirtual || rm.IsAbstract || rm.IsOverride)))
                                        break;
                                }
                                AppendExplicitInterfaceEvent(sb, iface, e, cls, ns);
                            }
                            break;
                    }
                }
            }

            sb.AppendLine("}");

            return sb.ToString();
        }


        /// <summary>
        /// 为可重写的实例方法生成派生类中的 override 方法实现 并注入日志和行为管道
        /// </summary>
        private static void AppendDerivedOverride(StringBuilder sb, IMethodSymbol method, string typeFullName, string callTarget, string currentNamespace)
        {
            
            var isGenericTask = method.ReturnType is INamedTypeSymbol nts && nts.IsGenericType && IsType(nts.ConstructedFrom, "System.Threading.Tasks.Task");
            
            var isTask = method.ReturnType is INamedTypeSymbol nts0 && !nts0.IsGenericType && IsType(nts0, "System.Threading.Tasks.Task");
            
            var isGenericValueTask = method.ReturnType is INamedTypeSymbol nts2 && nts2.IsGenericType && IsType(nts2.ConstructedFrom, "System.Threading.Tasks.ValueTask");
            
            var isValueTask = method.ReturnType is INamedTypeSymbol nts3 && !nts3.IsGenericType && IsType(nts3, "System.Threading.Tasks.ValueTask");
            
            var isAsyncEnumerable = (method.ReturnType is INamedTypeSymbol nts4 && nts4.IsGenericType && IsType(nts4.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable"))
                || method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal);
            
            var isTaskOfAsyncEnumerable = isGenericTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t1 && (
                (t1.IsGenericType && IsType(t1.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
                t1.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));
            
            var isValueTaskOfAsyncEnumerable = isGenericValueTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t2 && (
                (t2.IsGenericType && IsType(t2.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
                t2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));
            
            if (!isTaskOfAsyncEnumerable)
            {
                var rtText2 = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (rtText2.StartsWith("global::System.Threading.Tasks.Task<global::System.Collections.Generic.IAsyncEnumerable<", StringComparison.Ordinal))
                    isTaskOfAsyncEnumerable = true;
            }
            
            if (!isValueTaskOfAsyncEnumerable)
            {
                var rtText2 = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (rtText2.StartsWith("global::System.Threading.Tasks.ValueTask<global::System.Collections.Generic.IAsyncEnumerable<", StringComparison.Ordinal))
                    isValueTaskOfAsyncEnumerable = true;
            }

            var returnTypeFullText = method.ReturnType
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            var returnType = TrimCurrentNamespace(returnTypeFullText, currentNamespace);
            returnType = TrimCurrentNamespace(returnType, currentNamespace);
            
            var methodName = method.Name;
            
            var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
            
            var paramList = string.Join(", ", method.Parameters.Select(p => FormatParameter(p, includeDefault: false, currentNamespace)));
            
            var argList = string.Join(", ", method.Parameters.Select(p => (p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty) + p.Name + (p.RefKind == RefKind.None ? "!" : string.Empty)));

            var isByRefReturn = method.ReturnsByRef || method.ReturnsByRefReadonly;
            
            var hasByRefAny = isByRefReturn || method.Parameters.Any(p => p.RefKind != RefKind.None || p.Type.IsRefLikeType);
            
            var needsAsync = hasByRefAny && (isTask || isGenericTask || isValueTask || isGenericValueTask);
            
            var sigReturnType = method.ReturnsVoid
                ? "void"
                : isByRefReturn
                    ? (method.ReturnsByRefReadonly ? "ref readonly " : "ref ") + returnType
                    : returnType;

            sb.Append("    public override ").Append(needsAsync ? "async " : string.Empty).Append(sigReturnType).Append(' ').Append(methodName).Append(typeParams)
              .Append('(').Append(paramList).Append(')').AppendLine()
              .AppendLine("    {");

            if (method.Parameters.Length > 0)
            {
                var dictType = TrimCurrentNamespace("System.Collections.Generic.Dictionary<string, string?>", currentNamespace);
                sb.AppendLine("        var __argsDict = new " + dictType + "(" + method.Parameters.Length + ");");
                
                foreach (var p in method.Parameters)
                {
                    var isOut = p.RefKind == RefKind.Out;
                    
                    var isRefLike = p.Type.IsRefLikeType;
                    if (isOut || isRefLike)
                    {
                        sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = null;").AppendLine();
                    }
                    else
                    {
                        if (TryGetSkipPlaceholder(p.Type, out var __ph))
                        {
                            sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = \"")
                              .Append(__ph.Replace("\\", "\\\\").Replace("\"", "\\\""))
                              .Append("\";").AppendLine();
                        }
                        else
                        {
                            sb.Append("        try { __argsDict[\"").Append(p.Name).Append("\"] = JsonUtil.ToJson(")
                              .Append(p.Name).Append("); } catch { __argsDict[\"").Append(p.Name).Append("\"] = Convert.ToString(")
                              .Append(p.Name).Append("); }").AppendLine();
                        }
                    }
                }
                sb.AppendLine("        object? __argsObj = __argsDict;");
            }
            else
            {
                sb.AppendLine("        object? __argsObj = null;");
            }

            sb.AppendLine("        var __logMethod = \"" + typeFullName + "\" + \"." + methodName + "\";");
            sb.AppendLine("        var __logger = __sp?.GetService<ILoggerFactory>()?.CreateLogger(\"ProxyRuntime\");");

            var hasByRef = hasByRefAny;
            
            var behaviorSnippets = new List<string> { "new LoggingBehavior()" };
            
            var optionsSetters = new List<string>();
            
            foreach (var a in method.GetAttributes())
            {
                if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
                {
                    var include = !hasByRef || CanUseAsFilter(a);
                    if (include)
                    {
                        behaviorSnippets.Add($"new {behaviorFull}()");
                        if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                    }
                }
            }
            
            sb.AppendLine("        var __behaviors = new IInvocationAsyncBehavior[] { " + string.Join(", ", behaviorSnippets) + " };");
            
            var __hasReturn = isGenericTask || isGenericValueTask || (!isTask && !isValueTask && !method.ReturnsVoid) || isAsyncEnumerable;
            var __allowRet = __hasReturn && IsAllowReturnSerialization(method);
            
            sb.AppendLine("        var __ctx = new InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = Guid.CreateVersion7(), Log = true, HasReturnValue = " + (__hasReturn ? "true" : "false") + ", AllowReturnSerialization = " + (__allowRet ? "true" : "false") + ", ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
            
            if (optionsSetters.Count > 0) sb.AppendLine("        " + string.Join("\n        ", optionsSetters));

            if (hasByRef || isAsyncEnumerable || isTaskOfAsyncEnumerable || isValueTaskOfAsyncEnumerable)
            {
                sb.AppendLine("        var __filters = new List<IInvocationBehavior>();");
                sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is IInvocationBehavior __f) __filters.Add(__f); }");
                
                if (isAsyncEnumerable)
                {
                    // 对异步枚举结果进行包装 在迭代过程中收集每个元素的 JSON 并在完成后统一记录日志
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    var callExpr = callTarget + "." + methodName + typeParams + "(" + argList + ")";
                    
                    sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                    sb.AppendLine("            var __items = new List<object?>(16);");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __e = {callExpr}.GetAsyncEnumerator();");
                    sb.AppendLine("            try");
                    sb.AppendLine("            {");
                    sb.AppendLine("                while (true)");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    bool __moved;");
                    sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("                    if (!__moved) break;");
                    sb.AppendLine("                    var __item = __e.Current;");
                    sb.AppendLine("                    try { __items.Add(JsonUtil.ToObject(JsonUtil.ToJson(__item))); } catch { __items.Add(Convert.ToString(__item)); }");
                    sb.AppendLine("                    yield return __item;");
                    sb.AppendLine("                }");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                    sb.AppendLine("            }");
                    sb.AppendLine("            finally");
                    sb.AppendLine("            {");
                    sb.AppendLine("                await __e.DisposeAsync();");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                    sb.AppendLine($"        return __streamWrapper();");
                    sb.AppendLine("    }");
                    return; // 方法体已经在前面生成 此处直接返回结束代码生成
                }
                if (isTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            await {callTarget}.{methodName}{typeParams}({argList});");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    sb.AppendLine("        {");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isTaskOfAsyncEnumerable)
                {
                    var tItem = (((INamedTypeSymbol)((INamedTypeSymbol)method.ReturnType).TypeArguments[0]).TypeArguments[0])
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    var callExpr = callTarget + "." + methodName + typeParams + "(" + argList + ")";
                    
                    sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tItem}> __streamWrapper(){{");
                    sb.AppendLine("            var __items = new List<object?>(16);");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __s = await {callExpr};");
                    sb.AppendLine("            var __e = __s.GetAsyncEnumerator();");
                    sb.AppendLine("            try");
                    sb.AppendLine("            {");
                    sb.AppendLine("                while (true)");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    bool __moved;");
                    sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("                    if (!__moved) break;");
                    sb.AppendLine("                    var __item = __e.Current;");
                    sb.AppendLine("                    try { __items.Add(JsonUtil.ToObject(JsonUtil.ToJson(__item))); } catch { __items.Add(Convert.ToString(__item)); }");
                    sb.AppendLine("                    yield return __item;");
                    sb.AppendLine("                }");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                    sb.AppendLine("            }");
                    sb.AppendLine("            finally");
                    sb.AppendLine("            {");
                    sb.AppendLine("                await __e.DisposeAsync();");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                    sb.AppendLine($"        return global::System.Threading.Tasks.Task.FromResult<global::System.Collections.Generic.IAsyncEnumerable<{tItem}>>(__streamWrapper());");
                }
                else if (isGenericTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __res = await {callTarget}.{methodName}{typeParams}({argList});");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                    sb.AppendLine("            return __res;");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    sb.AppendLine("        {");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isValueTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            await {callTarget}.{methodName}{typeParams}({argList});");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                    sb.AppendLine("            return;");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    
                    sb.AppendLine("        {");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isGenericValueTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __res = await {callTarget}.{methodName}{typeParams}({argList});");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                    sb.AppendLine("            return __res;");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    sb.AppendLine("        {");
                    
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isByRefReturn)
                {
                    sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); ref var __ret = ref " + callTarget + "." + methodName + typeParams + "(" + argList + "); var __snap = __ret; foreach (var __f in __filters) __f.OnAfter(__ctx, __snap); return ref __ret; } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                }
                else if (method.ReturnsVoid)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    
                    sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); " + callTarget + "." + methodName + typeParams + "(" + argList + "); " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("        return;");
                }
                else
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    
                    sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); var __ret = " + callTarget + "." + methodName + typeParams + "(" + argList + "); " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __ret); return __ret; } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                }
            }
            else
            {
                if (isAsyncEnumerable)
                {
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    
                    var callExpr = callTarget + "." + methodName + typeParams + "(" + argList + ")";
                    sb.AppendLine($"        var __behaviors = new IInvocationAsyncBehavior[] {{ new LoggingBehavior() }};")
                      .AppendLine("        var __ctx = new InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = System.Guid.CreateVersion7(), Log = true, HasReturnValue = true, AllowReturnSerialization = true, ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
                    sb.AppendLine("        var __filters = new List<IInvocationBehavior>();");
                    sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is IInvocationBehavior __f) __filters.Add(__f); }");
                    sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                    sb.AppendLine("            var __items = new List<object?>(16);");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __e = {callExpr}.GetAsyncEnumerator();");
                    sb.AppendLine("            try");
                    sb.AppendLine("            {");
                    sb.AppendLine("                while (true)");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    bool __moved;");
                    sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("                    if (!__moved) break;");
                    sb.AppendLine("                    var __item = __e.Current;");
                    sb.AppendLine("                    try { __items.Add(JsonUtil.ToObject(JsonUtil.ToJson(__item))); } catch { __items.Add(Convert.ToString(__item)); }");
                    sb.AppendLine("                    yield return __item;");
                    sb.AppendLine("                }");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                    sb.AppendLine("            }");
                    sb.AppendLine("            finally");
                    sb.AppendLine("            {");
                    sb.AppendLine("                await __e.DisposeAsync();");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                    sb.AppendLine($"        return __streamWrapper();");
                    sb.AppendLine("    }");
                    return;
                }

            var runtime = "ProxyRuntime";
                
                if (isTask)
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                }
                else if (isGenericTask)
                {
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                }
                else if (isValueTask)
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                }
                else if (isGenericValueTask)
                {
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}) );");
                }
                else if (method.ReturnsVoid)
                {
                    sb.AppendLine($"        {runtime}.Execute<object?>(__ctx, () => {{ {callTarget}.{methodName}{typeParams}({argList}); return ValueTask.FromResult<object?>(null); }});");
                    
                    sb.AppendLine("        return;");
                }
                else
                {
                    // 兜底保护 如果编译期检测未识别为 Task 或 Task<T> 则根据返回类型字符串进行判断
                    if (returnTypeFullText.StartsWith("global::System.Threading.Tasks.Task<", StringComparison.Ordinal))
                    {
                        var tArgText = returnTypeFullText.Substring("global::System.Threading.Tasks.Task<".Length);
                        
                        tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                        tArgText = TrimCurrentNamespace(tArgText, currentNamespace);
                        
                        sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                    }
                    else if (string.Equals(returnTypeFullText, "global::System.Threading.Tasks.Task", StringComparison.Ordinal))
                    {
                        sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                    }
                    // 兜底保护 如果编译期检测未识别为 ValueTask 或 ValueTask<T> 则根据返回类型字符串进行判断
                    else if (returnTypeFullText.StartsWith("global::System.Threading.Tasks.ValueTask<", StringComparison.Ordinal))
                    {
                        var tArgText = returnTypeFullText.Substring("global::System.Threading.Tasks.ValueTask<".Length);
                        
                        tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                        tArgText = TrimCurrentNamespace(tArgText, currentNamespace);
                        
                        sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}) );");
                    }
                    else if (string.Equals(returnTypeFullText, "global::System.Threading.Tasks.ValueTask", StringComparison.Ordinal))
                    {
                        sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                    }
                    else
                    {
                        sb.AppendLine($"        return {runtime}.Execute<{returnType}>(__ctx, () => ValueTask.FromResult({callTarget}.{methodName}{typeParams}({argList})));");
                    }
                }
            }

            sb.AppendLine("    }");
        }


        /// <summary>
        /// 为接口方法生成在代理类中的显式接口实现 并注入行为管道和日志逻辑
        /// </summary>
        private static void AppendExplicitInterfaceMethod(StringBuilder sb, INamedTypeSymbol iface, IMethodSymbol method, IMethodSymbol? impl, string typeFullName, string currentNamespace)
        {
            // 在编译期根据接口方法和实现方法上的特性构建行为管道配置
            var isGenericTask = method.ReturnType is INamedTypeSymbol nts && nts.IsGenericType && IsType(nts.ConstructedFrom, "System.Threading.Tasks.Task");

            var isTask = method.ReturnType is INamedTypeSymbol nts0 && !nts0.IsGenericType && IsType(nts0, "System.Threading.Tasks.Task");

            var isGenericValueTask = method.ReturnType is INamedTypeSymbol nts2 && nts2.IsGenericType && IsType(nts2.ConstructedFrom, "System.Threading.Tasks.ValueTask");

            var isValueTask = method.ReturnType is INamedTypeSymbol nts3 && !nts3.IsGenericType && IsType(nts3, "System.Threading.Tasks.ValueTask");

            var isAsyncEnumerable = (method.ReturnType is INamedTypeSymbol nts4 && nts4.IsGenericType && IsType(nts4.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable"))
                || method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal);

            var isTaskOfAsyncEnumerable = isGenericTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t1 && (
                (t1.IsGenericType && IsType(t1.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
                t1.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));

            var isValueTaskOfAsyncEnumerable = isGenericValueTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t2 && (
                (t2.IsGenericType && IsType(t2.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
                t2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));

            var returnTypeFullText = method.ReturnType
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            var returnType = TrimCurrentNamespace(returnTypeFullText, currentNamespace);

            var ifaceDisplay = TrimCurrentNamespace(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), currentNamespace);

            var methodName = method.Name;

            var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;

            var paramList = string.Join(", ", method.Parameters.Select(p => FormatParameter(p, includeDefault: false, currentNamespace)));

            var argList = string.Join(", ", method.Parameters.Select(p => (p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty) + p.Name + (p.RefKind == RefKind.None ? "!" : string.Empty)));


            var isByRefReturn = method.ReturnsByRef || method.ReturnsByRefReadonly;

            var hasByRef2_head = isByRefReturn || method.Parameters.Any(p => p.RefKind != RefKind.None || p.Type.IsRefLikeType);

            var needsAsync2 = hasByRef2_head && (isTask || isGenericTask || isValueTask || isGenericValueTask);

            var sigReturnType = method.ReturnsVoid
                ? "void"
                : isByRefReturn
                    ? (method.ReturnsByRefReadonly ? "ref readonly " : "ref ") + returnType
                    : returnType;

            sb.Append("    ").Append(needsAsync2 ? "async " : string.Empty).Append(sigReturnType).Append(' ').Append(ifaceDisplay).Append('.').Append(methodName).Append(typeParams)
              .Append('(').Append(paramList).Append(')').AppendLine()
              .AppendLine("    {");

            if (method.Parameters.Length > 0)
            {
                var dictType = TrimCurrentNamespace("System.Collections.Generic.Dictionary<string, string?>", currentNamespace);
                sb.AppendLine("        var __argsDict = new " + dictType + "(" + method.Parameters.Length + ");");

                foreach (var p in method.Parameters)
                {
                    var isOut = p.RefKind == RefKind.Out;
                    var isRefLike = p.Type.IsRefLikeType;

                    if (isOut || isRefLike)
                    {
                        sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = null;").AppendLine();
                    }
                    else
                    {
                        if (TryGetSkipPlaceholder(p.Type, out var __ph))
                        {
                            sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = \"")
                              .Append(__ph.Replace("\\", "\\\\").Replace("\"", "\\\""))
                              .Append("\";").AppendLine();
                        }
                        else
                        {
                            sb.Append("        try { __argsDict[\"").Append(p.Name).Append("\"] = JsonUtil.ToJson(")
                              .Append(p.Name).Append("); } catch { __argsDict[\"").Append(p.Name).Append("\"] = Convert.ToString(")
                              .Append(p.Name).Append("); }").AppendLine();
                        }
                    }
                }

                sb.AppendLine("        object? __argsObj = __argsDict;");
            }
            else
            {
                sb.AppendLine("        object? __argsObj = null;");
            }

            sb.AppendLine("        var __logMethod = \"" + typeFullName + "\" + \"." + methodName + "\";");
            sb.AppendLine("        var __logger = __sp?.GetService<ILoggerFactory>()?.CreateLogger(\"ProxyRuntime\");");

            var hasByRef2 = isByRefReturn || method.Parameters.Any(p => p.RefKind != RefKind.None || p.Type.IsRefLikeType);

            var behaviorSnippets = new List<string> { "new LoggingBehavior()" };

            var optionsSetters = new List<string>();

            foreach (var a in method.GetAttributes())
            {
                if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
                {
                    var include = !hasByRef2 || CanUseAsFilter(a);

                    if (include)
                    {
                        behaviorSnippets.Add($"new {behaviorFull}()");

                        if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                    }
                }
            }

            if (impl is not null)
            {
                foreach (var a in impl.GetAttributes())
                {
                    if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
                    {
                        var include = !hasByRef2 || CanUseAsFilter(a);

                        if (include)
                        {
                            behaviorSnippets.Add($"new {behaviorFull}()");

                            if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                        }
                    }
                }
            }

            sb.AppendLine("        var __behaviors = new IInvocationAsyncBehavior[] { " + string.Join(", ", behaviorSnippets) + " };");

            var __hasReturn = isGenericTask || isGenericValueTask || (!isTask && !isValueTask && !method.ReturnsVoid) || isAsyncEnumerable;

            var __allowRet = __hasReturn && IsAllowReturnSerialization(method);

            sb.AppendLine("        var __ctx = new InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = Guid.CreateVersion7(), Log = true, HasReturnValue = " + (__hasReturn ? "true" : "false") + ", AllowReturnSerialization = " + (__allowRet ? "true" : "false") + ", ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
            
            if (optionsSetters.Count > 0) sb.AppendLine("        " + string.Join("\n        ", optionsSetters));

            var call = "base." + methodName + typeParams + "(" + argList + ")";
            
            if (hasByRef2 || isAsyncEnumerable || isTaskOfAsyncEnumerable || isValueTaskOfAsyncEnumerable)
            {
                sb.AppendLine("        var __filters = new List<IInvocationBehavior>();");
                sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is IInvocationBehavior __f) __filters.Add(__f); }");
                
                if (isAsyncEnumerable)
                {
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    var callExpr2 = "base." + methodName + typeParams + "(" + argList + ")";
                    sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                    sb.AppendLine("            var __items = new List<object?>(16);");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __e = {callExpr2}.GetAsyncEnumerator();");
                    sb.AppendLine("            try");
                    sb.AppendLine("            {");
                    sb.AppendLine("                while (true)");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    bool __moved;");
                    sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("                    if (!__moved) break;");
                    sb.AppendLine("                    var __item = __e.Current;");
                    sb.AppendLine("                    try { __items.Add(JsonUtil.ToObject(JsonUtil.ToJson(__item))); } catch { __items.Add(Convert.ToString(__item)); }");
                    sb.AppendLine("                    yield return __item;");
                    sb.AppendLine("                }");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                    sb.AppendLine("            }");
                    sb.AppendLine("            finally");
                    sb.AppendLine("            {");
                    sb.AppendLine("                await __e.DisposeAsync();");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                    sb.AppendLine($"        return __streamWrapper();");
                    sb.AppendLine("    }");
                    return;
                }
                
                if (isTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            await {call};");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    sb.AppendLine("        {");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isTaskOfAsyncEnumerable)
                {
                    var tItem = (((INamedTypeSymbol)((INamedTypeSymbol)method.ReturnType).TypeArguments[0]).TypeArguments[0])
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tItem}> __streamWrapper(){{");
                    sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __s = await {call};");
                    sb.AppendLine("            var __e = __s.GetAsyncEnumerator();");
                    sb.AppendLine("            try");
                    sb.AppendLine("            {");
                    sb.AppendLine("                while (true)");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    bool __moved;");
                    sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("                    if (!__moved) break;");
                    sb.AppendLine("                    var __item = __e.Current;");
                    sb.AppendLine("                    try { __items.Add(JsonUtil.ToObject(JsonUtil.ToJson(__item))); } catch { __items.Add(Convert.ToString(__item)); }");
                    sb.AppendLine("                    yield return __item;");
                    sb.AppendLine("                }");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                    sb.AppendLine("            }");
                    sb.AppendLine("            finally");
                    sb.AppendLine("            {");
                    sb.AppendLine("                await __e.DisposeAsync();");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                    sb.AppendLine($"        return global::System.Threading.Tasks.Task.FromResult<global::System.Collections.Generic.IAsyncEnumerable<{tItem}>>(__streamWrapper());");
                }
                else if (isGenericTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __res = await {call};");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                    sb.AppendLine("            return __res;");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    sb.AppendLine("        {");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isValueTaskOfAsyncEnumerable)
                {
                    var tItem = (((INamedTypeSymbol)((INamedTypeSymbol)method.ReturnType).TypeArguments[0]).TypeArguments[0])
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tItem}> __streamWrapper(){{");
                    sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __s = await {call};");
                    sb.AppendLine("            var __e = __s.GetAsyncEnumerator();");
                    sb.AppendLine("            try");
                    sb.AppendLine("            {");
                    sb.AppendLine("                while (true)");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    bool __moved;");
                    sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("                    if (!__moved) break;");
                    sb.AppendLine("                    var __item = __e.Current;");
                    sb.AppendLine("                    try { __items.Add(JsonUtil.ToObject(JsonUtil.ToJson(__item))); } catch { __items.Add(Convert.ToString(__item)); }");
                    sb.AppendLine("                    yield return __item;");
                    sb.AppendLine("                }");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                    sb.AppendLine("            }");
                    sb.AppendLine("            finally");
                    sb.AppendLine("            {");
                    sb.AppendLine("                await __e.DisposeAsync();");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                    sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask<global::System.Collections.Generic.IAsyncEnumerable<{tItem}>>(__streamWrapper());");
                }
                else if (isValueTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            await {call};");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                    sb.AppendLine("            return;");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    sb.AppendLine("        {");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isGenericValueTask)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try");
                    sb.AppendLine("        {");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine($"            var __res = await {call};");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                    sb.AppendLine("            return __res;");
                    sb.AppendLine("        }");
                    sb.AppendLine("        catch (global::System.Exception __ex)");
                    sb.AppendLine("        {");
                    if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("            throw;");
                    sb.AppendLine("        }");
                }
                else if (isByRefReturn)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); ref var __ret = ref " + call + "; var __snap = __ret; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __snap); return ref __ret; } catch (global::System.Exception __ex) { " + updateSnippet + " foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                }
                else if (method.ReturnsVoid)
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); " + call + "; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); } catch (global::System.Exception __ex) { " + updateSnippet + " foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                    sb.AppendLine("        return;");
                }
                else
                {
                    var updateSnippet = BuildArgsUpdateSnippet(method);
                    sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); var __ret = " + call + "; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __ret); return __ret; } catch (global::System.Exception __ex) { " + updateSnippet + " foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                }
            }
            else
            {
                if (isAsyncEnumerable)
                {
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    var callExpr3 = "base." + methodName + typeParams + "(" + argList + ")";
                    sb.AppendLine("        var __behaviors = new IInvocationAsyncBehavior[] { new LoggingBehavior() };")
                      .AppendLine("        var __ctx = new InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = Guid.CreateVersion7(), Log = true, HasReturnValue = true, AllowReturnSerialization = true, ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
                    sb.AppendLine("        var __filters = new List<IInvocationBehavior>();");
                    sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is IInvocationBehavior __f) __filters.Add(__f); }");
                    sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                    sb.AppendLine("            var __items = new List<object?>(16);");
                    sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                    sb.AppendLine("            try");
                    sb.AppendLine("            {");
                    sb.AppendLine($"                await foreach (var __item in {callExpr3})");
                    sb.AppendLine("                {");
                    sb.AppendLine("                    try { __items.Add(JsonUtil.ToObject(JsonUtil.ToJson(__item))); } catch { __items.Add(Convert.ToString(__item)); }");
                    sb.AppendLine("                    yield return __item;");
                    sb.AppendLine("                }");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                    sb.AppendLine("            }");
                    sb.AppendLine("            catch (global::System.Exception __ex)");
                    sb.AppendLine("            {");
                    sb.AppendLine("                foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                    sb.AppendLine("                throw;");
                    sb.AppendLine("            }");
                    sb.AppendLine("        }");
                    sb.AppendLine($"        return __streamWrapper();");
                    sb.AppendLine("    }");
                    return;
                }

                var runtime = "ProxyRuntime";
                
                if (isTask)
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
                }
                else if (isGenericTask)
                {
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {call});");
                }
                else if (isValueTask)
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
                }
                else if (isGenericValueTask)
                {
                    var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                        .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                    
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {call} );");
                }
                else if (method.ReturnsVoid)
                {
                    sb.AppendLine($"        {runtime}.Execute<object?>(__ctx, () => {{ {call}; return ValueTask.FromResult<object?>(null); }});");
                    sb.AppendLine("        return;");
                }
                else
                {
                    // 兜底保护 如果编译期检测未识别为 Task 或 Task<T> 则根据返回类型字符串进行判断
                    if (returnTypeFullText.StartsWith("global::System.Threading.Tasks.Task<", StringComparison.Ordinal))
                    {
                        var tArgText = returnTypeFullText.Substring("global::System.Threading.Tasks.Task<".Length);
                       
                        tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                        tArgText = TrimCurrentNamespace(tArgText, currentNamespace);
                       
                        sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {call});");
                    }
                    else if (string.Equals(returnTypeFullText, "global::System.Threading.Tasks.Task", StringComparison.Ordinal))
                    {
                        sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
                    }
                    // 兜底保护 如果编译期检测未识别为 ValueTask 或 ValueTask<T> 则根据返回类型字符串进行判断
                    else if (returnTypeFullText.StartsWith("global::System.Threading.Tasks.ValueTask<", StringComparison.Ordinal))
                    {
                        var tArgText = returnTypeFullText.Substring("global::System.Threading.Tasks.ValueTask<".Length);
                        
                        tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                        tArgText = TrimCurrentNamespace(tArgText, currentNamespace);
                        
                        sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {call} );");
                    }
                    else if (string.Equals(returnTypeFullText, "global::System.Threading.Tasks.ValueTask", StringComparison.Ordinal))
                    {
                        sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
                    }
                    else
                    {
                        sb.AppendLine($"        return {runtime}.Execute<{returnType}>(__ctx, () => ValueTask.FromResult({call}));");
                    }
                }
            }

            sb.AppendLine("    }");
        }


        /// <summary>
        /// 为接口属性生成在代理类中的显式接口实现 直接转发到基类属性
        /// </summary>
        private static void AppendExplicitInterfaceProperty(StringBuilder sb, INamedTypeSymbol iface, IPropertySymbol prop, INamedTypeSymbol cls, string currentNamespace)
        {
            var typeName = TrimCurrentNamespace(prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), currentNamespace);

            var ifaceDisplay = TrimCurrentNamespace(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), currentNamespace);

            sb.Append("    ").Append(typeName).Append(' ').Append(ifaceDisplay).Append('.').Append(prop.Name).AppendLine()
              .AppendLine("    {");

            if (prop.GetMethod is not null)
            {
                sb.AppendLine("        get => base." + prop.Name + ";");
            }

            if (prop.SetMethod is not null)
            {
                sb.AppendLine("        set => base." + prop.Name + " = value;");
            }

            sb.AppendLine("    }");
        }


        /// <summary>
        /// 为接口事件生成在代理类中的显式接口实现 直接转发到基类事件
        /// </summary>
        private static void AppendExplicitInterfaceEvent(StringBuilder sb, INamedTypeSymbol iface, IEventSymbol ev, INamedTypeSymbol cls, string currentNamespace)
        {
            var typeName = TrimCurrentNamespace(ev.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), currentNamespace);

            var ifaceDisplay = TrimCurrentNamespace(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), currentNamespace);

            sb.Append("    event ").Append(typeName).Append(' ').Append(ifaceDisplay).Append('.').Append(ev.Name).AppendLine()
              .AppendLine("    {")
              .AppendLine("        add => base." + ev.Name + " += value;")
              .AppendLine("        remove => base." + ev.Name + " -= value;")
              .AppendLine("    }");
        }


        /// <summary>
        /// 从行为特性中提取行为类型和可选配置初始化代码
        /// </summary>
        private static bool TryGetBehaviorSpec(AttributeData a, out string behaviorFull, out string? optSetter)
        {
            behaviorFull = string.Empty;
            optSetter = null;
            var attrClass = a.AttributeClass as INamedTypeSymbol;

            if (attrClass is null) return false;

            INamedTypeSymbol? proxyBase = null;

            for (var t = attrClass; t is not null; t = t.BaseType as INamedTypeSymbol)
            {
                var constructed = t.ConstructedFrom ?? t;
                if (constructed is INamedTypeSymbol nt && IsNamedType(nt, "SourceGenerator.Runtime.Attributes", "ProxyBehaviorAttribute"))
                {
                    proxyBase = t; // 保留具体泛型基类 以便读取 TypeArguments 信息
                    break;
                }
            }

            if (proxyBase is null) return false;

            ITypeSymbol? behaviorTypeSymbol = null;
            INamedTypeSymbol? optionsTypeSymbol = null;

            if (proxyBase.IsGenericType)
            {
                if (proxyBase.TypeArguments.Length == 1)
                {
                    behaviorTypeSymbol = proxyBase.TypeArguments[0];
                }
                else if (proxyBase.TypeArguments.Length == 2)
                {
                    behaviorTypeSymbol = proxyBase.TypeArguments[0];
                    optionsTypeSymbol = proxyBase.TypeArguments[1] as INamedTypeSymbol;
                }
            }

            if (behaviorTypeSymbol is null) return false;

            behaviorFull = TrimCurrentNamespace(behaviorTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), string.Empty);

            if (optionsTypeSymbol is not null)
            {
                var assigns = new List<string>();
                foreach (var kv in a.NamedArguments)
                {
                    var propName = kv.Key;
                    var prop = optionsTypeSymbol.GetMembers().OfType<IPropertySymbol>().FirstOrDefault(p => p.Name == propName && !p.IsReadOnly);
                    if (prop is null) continue;
                    var lit = ToCSharpLiteral(kv.Value);
                    if (lit is null) continue;
                    assigns.Add(propName + " = " + lit);
                }
                var optFull = TrimCurrentNamespace(optionsTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), string.Empty);
                if (optFull.StartsWith("Options.", StringComparison.Ordinal))
                {
                    optFull = optFull.Substring("Options.".Length);
                }
                var init = assigns.Count > 0 ? " { " + string.Join(", ", assigns) + " }" : string.Empty;
                optSetter = $"__ctx.SetFeature(new {optFull}{init});";
            }

            return true;
        }


        /// <summary>
        /// 判断行为特性对应的行为类型是否实现同步过滤接口 从而可参与带 ref 的同步调用管道
        /// </summary>
        private static bool CanUseAsFilter(AttributeData a)
        {
            // 尝试判断行为类型是否实现 IInvocationBehavior 以便在带 ref 的同步调用路径中参与过滤
            var attrClass = a.AttributeClass as INamedTypeSymbol;

            if (attrClass is null) return false;

            INamedTypeSymbol? proxyBase = null;

            for (var t = attrClass; t is not null; t = t.BaseType as INamedTypeSymbol)
            {
                var constructed = t.ConstructedFrom ?? t;
                if (constructed is INamedTypeSymbol nt && IsNamedType(nt, "SourceGenerator.Runtime.Attributes", "ProxyBehaviorAttribute"))
                {
                    proxyBase = t;
                    break;
                }
            }

            if (proxyBase is null) return false;

            ITypeSymbol? behaviorTypeSymbol = null;

            if (proxyBase.IsGenericType && proxyBase.TypeArguments.Length >= 1)
            {
                behaviorTypeSymbol = proxyBase.TypeArguments[0];
            }

            if (behaviorTypeSymbol is INamedTypeSymbol nts)
            {
                foreach (var itf in nts.AllInterfaces)
                {
                    if (IsType(itf, "SourceGenerator.Runtime.Pipeline.IInvocationBehavior")) return true;
                }
            }

            return false;
        }


        /// <summary>
        /// 将 Roslyn 参数符号格式化为 C# 方法参数文本 可选择是否包含默认值
        /// </summary>
        private static string FormatParameter(IParameterSymbol p, bool includeDefault, string? currentNamespace = null)
        {
            var type = p.Type
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            if (!string.IsNullOrEmpty(currentNamespace))
            {
                type = TrimCurrentNamespace(type, currentNamespace!);
            }

            var mod = p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty;

            // 保留与依赖注入相关的参数特性 例如 FromKeyedServices 和 FromServices
            var attrPrefix = BuildParameterAttributesPrefix(p);

            string @default = string.Empty;

            if (includeDefault && p.HasExplicitDefaultValue)
            {
                if (p.ExplicitDefaultValue is null)
                {
                    @default = p.Type.IsReferenceType ? " = null" : " = default";
                }
                else if (p.ExplicitDefaultValue is string s)
                {
                    @default = " = \"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"";
                }
                else if (p.ExplicitDefaultValue is bool b)
                {
                    @default = b ? " = true" : " = false";
                }
                else if (p.ExplicitDefaultValue is char ch)
                {
                    var esc = ch == '\'' ? "\\'" : ch.ToString();
                    @default = " = '" + esc + "'";
                }
                else if (p.ExplicitDefaultValue is IFormattable f)
                {
                    @default = " = " + f.ToString(null, System.Globalization.CultureInfo.InvariantCulture);
                }
                else
                {
                    @default = " = " + p.ExplicitDefaultValue.ToString();
                }
            }

            return attrPrefix + mod + type + " " + p.Name + @default;
        }


        /// <summary>
        /// 构建参数前缀中的特性文本 主要用于保留依赖注入相关的绑定特性
        /// </summary>
        private static string BuildParameterAttributesPrefix(IParameterSymbol p)
        {
            if (p is null) return string.Empty;

            var attrs = p.GetAttributes();

            if (attrs.Length == 0) return string.Empty;

            var sb = new StringBuilder();

            foreach (var attr in attrs)
            {
                if (attr.AttributeClass is not INamedTypeSymbol at) continue;

                // 仅转发影响参数解析的依赖注入绑定特性
                //  - 表示按键解析服务的 Microsoft.Extensions.DependencyInjection.FromKeyedServicesAttribute(object key)
                //  - 表示从容器解析服务的 Microsoft.Extensions.DependencyInjection.FromServicesAttribute()
                if (IsNamedType(at, "Microsoft.Extensions.DependencyInjection", "FromKeyedServicesAttribute"))
                {

                    // 构造函数只有一个参数 作为键值 object?
                    var keyText = FormatTypedConstant(attr.ConstructorArguments.FirstOrDefault());
                    sb.Append("[global::Microsoft.Extensions.DependencyInjection.FromKeyedServices(")
                      .Append(keyText)
                      .Append(")] ");

                    // 具体初始化代码稍后直接拼接 此处先跳过
                }
                else if (IsNamedType(at, "Microsoft.Extensions.DependencyInjection", "FromServicesAttribute"))
                {
                    sb.Append("[global::Microsoft.Extensions.DependencyInjection.FromServices] ");
                }
            }

            var result = sb.ToString();

            return result;
        }


        /// <summary>
        /// 如果类型在当前命名空间下，裁剪掉重复的命名空间前缀提升可读性
        /// </summary>
        private static string TrimCurrentNamespace(string typeName, string currentNamespace)
        {
            if (string.IsNullOrEmpty(typeName)) return typeName;

            // 先移除 global:: 前缀
            typeName = typeName.Replace("global::", string.Empty);

            // 移除当前命名空间前缀
            if (!string.IsNullOrEmpty(currentNamespace))
            {
                typeName = typeName.Replace(currentNamespace + ".", string.Empty);
            }

            // 常用 BCL 命名空间前缀去除，便于输出简洁类型名
            typeName = typeName.Replace("System.Collections.Generic.", string.Empty)
                               .Replace("System.Threading.Tasks.", string.Empty)
                               .Replace("System.", string.Empty);
            // 常用 Runtime 命名空间前缀去除
            typeName = typeName.Replace("SourceGenerator.Runtime.Pipeline.Behaviors.", string.Empty)
                               .Replace("SourceGenerator.Runtime.Pipeline.", string.Empty)
                               .Replace("SourceGenerator.Runtime.", string.Empty);

            return typeName;
        }


        /// <summary>
        /// 将 TypedConstant 转换为对应的 C# 字面量字符串
        /// </summary>
        private static string FormatTypedConstant(TypedConstant constant)
        {
            if (constant.IsNull) return "null";

            try
            {
                var v = constant.Value;

                if (v is null) return "null";

                // 尽量将枚举常量序列化为完全限定的 Enum.Member 形式
                if (constant.Type is INamedTypeSymbol enumType && enumType.TypeKind == TypeKind.Enum)
                {
                    var fqEnum = enumType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    var field = enumType.GetMembers()
                        .OfType<IFieldSymbol>()
                        .FirstOrDefault(f => f.HasConstantValue && Equals(f.ConstantValue, v));

                    if (field is not null)
                    {
                        return fqEnum + "." + field.Name;
                    }

                    // 兜底方案 将数值字面量强制转换为枚举类型
                    var numText = (v is IFormattable ff)
                        ? ff.ToString(null, System.Globalization.CultureInfo.InvariantCulture) ?? "0"
                        : v.ToString() ?? "0";

                    return "(" + fqEnum + ")" + numText;
                }
                return v switch
                {
                    string s => "\"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"",

                    char ch => "'" + (ch == '\'' ? "\\'" : ch.ToString()) + "'",

                    bool b => b ? "true" : "false",

                    IFormattable f => f.ToString(null, System.Globalization.CultureInfo.InvariantCulture) ?? "null",

                    _ => v.ToString() ?? "null"
                };
            }
            catch
            {
                // 发生异常时回退到通用的中性表示
                return "null";
            }
        }


        /// <summary>
        /// 判断给定类型在完全限定名层面是否等于指定元数据名称
        /// </summary>
        private static bool IsType(ITypeSymbol t, string metadataName)
        {
            // 通过完全限定名进行精确比较 对泛型类型使用未构造的泛型定义进行比较
            if (t is INamedTypeSymbol nt)
            {
                var open = nt.IsGenericType && nt.ConstructedFrom is INamedTypeSymbol cf ? cf : nt;

                var fq = open.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                var expected = metadataName.StartsWith("global::", StringComparison.Ordinal)
                    ? metadataName
                    : "global::" + metadataName;

                return string.Equals(fq, expected, StringComparison.Ordinal);
            }
            else
            {
                var fq = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                var expected = metadataName.StartsWith("global::", StringComparison.Ordinal)
                    ? metadataName
                    : "global::" + metadataName;

                return string.Equals(fq, expected, StringComparison.Ordinal);
            }
        }


        /// <summary>
        /// 判断命名类型是否匹配指定的命名空间 名称以及可选泛型参数个数
        /// </summary>
        private static bool IsNamedType(INamedTypeSymbol symbol, string @namespace, string name, int? arity = null)
        {
            var ns = GetFullNamespace(symbol.ContainingNamespace);

            if (!string.Equals(ns, @namespace, StringComparison.Ordinal)) return false;

            if (!string.Equals(symbol.Name, name, StringComparison.Ordinal)) return false;

            if (arity.HasValue && symbol.Arity != arity.Value) return false;

            return true;
        }


        /// <summary>
        /// 在编译期判断参数类型是否需要跳过 JSON 序列化并用占位字符串替代
        /// </summary>
        private static bool TryGetSkipPlaceholder(ITypeSymbol type, out string placeholder)
        {
            placeholder = "<skipped>";

            // 取消相关类型
            if (IsType(type, "System.Threading.CancellationToken")) { placeholder = "<cancellation-token>"; return true; }
            if (IsType(type, "System.Threading.CancellationTokenSource")) { placeholder = "<cancellation-token-source>"; return true; }

            // 委托类型
            if (type.TypeKind == TypeKind.Delegate) { placeholder = "<delegate>"; return true; }

            // 流与文本读写相关类型
            if (IsOrDerivedFrom(type, "System.IO.Stream")) { placeholder = "<stream>"; return true; }
            if (IsOrDerivedFrom(type, "System.IO.TextReader")) { placeholder = "<text-reader>"; return true; }
            if (IsOrDerivedFrom(type, "System.IO.TextWriter")) { placeholder = "<text-writer>"; return true; }

            // 管道相关类型 System.IO.Pipelines
            if (IsType(type, "System.IO.Pipelines.PipeReader")) { placeholder = "<pipe-reader>"; return true; }
            if (IsType(type, "System.IO.Pipelines.PipeWriter")) { placeholder = "<pipe-writer>"; return true; }

            // 通道相关泛型类型 System.Threading.Channels
            if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelReader", 1)) { placeholder = "<channel-reader>"; return true; }
            if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelWriter", 1)) { placeholder = "<channel-writer>"; return true; }

            // ASP.NET Core Http 相关类型
            var ns = GetFullNamespace(type.ContainingNamespace);
            if (ns.StartsWith("Microsoft.AspNetCore.Http", StringComparison.Ordinal)) { placeholder = "<http-context>"; return true; }

            // 安全主体相关类型
            if (IsType(type, "System.Security.Claims.ClaimsPrincipal") || ImplementsInterface(type, "System.Security.Principal.IPrincipal"))
            { placeholder = "<principal>"; return true; }

            // 依赖注入和日志相关类型
            if (ImplementsInterface(type, "System.IServiceProvider")) { placeholder = "<service-provider>"; return true; }
            if (ImplementsInterfaceNamed(type, "Microsoft.Extensions.Logging", "ILogger")) { placeholder = "<logger>"; return true; }

            // 数据库访问相关类型
            if (IsOrDerivedFrom(type, "System.Data.Common.DbConnection") || ImplementsInterface(type, "System.Data.IDbConnection"))
            { placeholder = "<db-connection>"; return true; }
            if (IsOrDerivedFrom(type, "System.Data.Common.DbTransaction")) { placeholder = "<db-transaction>"; return true; }
            if (IsOrDerivedFrom(type, "System.Data.Common.DbCommand")) { placeholder = "<db-command>"; return true; }

            // HTTP 通信相关类型
            if (IsType(type, "System.Net.Http.HttpClient")) { placeholder = "<http-client>"; return true; }
            if (IsType(type, "System.Net.Http.HttpRequestMessage")) { placeholder = "<http-request>"; return true; }
            if (IsType(type, "System.Net.Http.HttpResponseMessage")) { placeholder = "<http-response>"; return true; }

            // 表达式树相关类型
            if (IsOrDerivedFrom(type, "System.Linq.Expressions.Expression")) { placeholder = "<expression>"; return true; }

            return false;
        }


        /// <summary>
        /// 判断类型本身或其继承链上是否存在指定元数据名称的类型
        /// </summary>
        private static bool IsOrDerivedFrom(ITypeSymbol type, string metadataName)
        {
            for (var t = type; t is not null; t = t.BaseType)
            {
                if (IsType(t, metadataName)) return true;
            }

            return false;
        }


        /// <summary>
        /// 判断类型本身或其继承链上是否存在指定命名空间 名称和泛型参数个数的泛型类型
        /// </summary>
        private static bool IsOrDerivedFromGeneric(ITypeSymbol type, string @namespace, string name, int arity)
        {
            for (var t = type; t is not null; t = t.BaseType)
            {
                if (t is INamedTypeSymbol nt && nt.IsGenericType && IsNamedType(nt.ConstructedFrom, @namespace, name, arity))
                    return true;
            }

            return false;
        }


        /// <summary>
        /// 判断类型是否实现给定元数据名称的接口
        /// </summary>
        private static bool ImplementsInterface(ITypeSymbol type, string metadataName)
        {
            foreach (var i in type.AllInterfaces)
            {
                if (IsType(i, metadataName)) return true;
            }

            return false;
        }


        /// <summary>
        /// 判断类型是否实现指定命名空间和名称以及可选泛型参数个数的接口
        /// </summary>
        private static bool ImplementsInterfaceNamed(ITypeSymbol type, string @namespace, string name, int? arity = null)
        {
            foreach (var i in type.AllInterfaces)
            {
                if (i is INamedTypeSymbol nt && IsNamedType(nt, @namespace, name, arity)) return true;
            }

            return false;
        }


        /// <summary>
        /// 判断方法返回值类型在日志中是否允许进行序列化输出
        /// </summary>
        private static bool IsAllowReturnSerialization(IMethodSymbol method)
        {
            var rt = method.ReturnType;

            // 异步流类型使用占位符记录日志 视为可记录类型
            if ((rt is INamedTypeSymbol nts4 && nts4.IsGenericType && IsType(nts4.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable"))
                || rt.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", StringComparison.Ordinal))
                return true;

            // 无返回值的 Task 或 ValueTask
            if (rt is INamedTypeSymbol ntsTask && !ntsTask.IsGenericType && IsType(ntsTask, "System.Threading.Tasks.Task"))
                return false;

            if (rt is INamedTypeSymbol ntsVt && !ntsVt.IsGenericType && IsType(ntsVt, "System.Threading.Tasks.ValueTask"))
                return false;

            // 对 Task<T> 和 ValueTask<T> 进行解包 使用其泛型参数做判断
            if (rt is INamedTypeSymbol ntsG && ntsG.IsGenericType)
            {
                if (IsType(ntsG.ConstructedFrom, "System.Threading.Tasks.Task") || IsType(ntsG.ConstructedFrom, "System.Threading.Tasks.ValueTask"))
                {
                    var tArg = ntsG.TypeArguments[0];
                    return IsReturnTypeLoggableCore(tArg);
                }
            }

            if (method.ReturnsVoid) return false;

            return IsReturnTypeLoggableCore(rt);
        }


        /// <summary>
        /// 判断具体类型在日志中是否适合作为返回值进行序列化记录
        /// </summary>
        private static bool IsReturnTypeLoggableCore(ITypeSymbol type)
        {
            if (IsOrDerivedFrom(type, "System.IO.Stream")) return false;

            if (IsOrDerivedFrom(type, "System.IO.TextReader")) return false;

            if (IsOrDerivedFrom(type, "System.IO.TextWriter")) return false;

            if (IsType(type, "System.IO.Pipelines.PipeReader")) return false;

            if (IsType(type, "System.IO.Pipelines.PipeWriter")) return false;

            if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelReader", 1)) return false;

            if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelWriter", 1)) return false;

            if (IsOrDerivedFrom(type, "System.Data.Common.DbConnection") || ImplementsInterface(type, "System.Data.IDbConnection")) return false;

            if (IsOrDerivedFrom(type, "System.Data.Common.DbTransaction")) return false;

            if (IsOrDerivedFrom(type, "System.Data.Common.DbCommand")) return false;

            if (IsType(type, "System.Net.Http.HttpRequestMessage")) return false;

            if (IsType(type, "System.Net.Http.HttpResponseMessage")) return false;

            if (IsType(type, "System.Net.Http.HttpClient")) return false;

            if (type.TypeKind == TypeKind.Delegate) return false;

            if (IsOrDerivedFrom(type, "System.Linq.Expressions.Expression")) return false;

            if (IsType(type, "System.Security.Claims.ClaimsPrincipal") || ImplementsInterface(type, "System.Security.Principal.IPrincipal")) return false;

            return true;
        }


        /// <summary>
        /// 获取命名空间的完整限定名 对全局命名空间返回空字符串
        /// </summary>
        private static string GetFullNamespace(INamespaceSymbol ns)
        {
            if (ns == null || ns.IsGlobalNamespace) return string.Empty;

            var stack = new Stack<string>();

            for (var n = ns; n is not null && !n.IsGlobalNamespace; n = n.ContainingNamespace)
            {
                stack.Push(n.Name);
            }

            return string.Join(".", stack);
        }


        /// <summary>
        /// 为带 ref 或 out 参数的方法构建调用后刷新参数快照的代码片段
        /// </summary>
        private static string BuildArgsUpdateSnippet(IMethodSymbol method)
        {
            var updates = new List<string>();

            foreach (var p in method.Parameters)
            {
                if (p.RefKind != RefKind.None)
                {
                    // 调用完成后刷新 ref out in 参数在参数字典中的值
                    if (TryGetSkipPlaceholder(p.Type, out var ph))
                    {
                        var escaped = ph.Replace("\\", "\\\\").Replace("\"", "\\\"");
                        updates.Add($"__argsDict[\"{p.Name}\"] = \"{escaped}\";");
                    }
                    else
                    {
                        updates.Add($"try {{ __argsDict[\"{p.Name}\"] = JsonUtil.ToJson({p.Name}); }} catch {{ __argsDict[\"{p.Name}\"] = Convert.ToString({p.Name}); }}");
                    }
                }
            }

            return updates.Count == 0 ? string.Empty : string.Join(" ", updates);
        }


        /// <summary>
        /// 构建代理类的类型参数声明部分 并统一包含外层和内层所有类型参数
        /// </summary>
        private static string BuildTypeParametersDecl(INamedTypeSymbol cls)
        {
            // 将所有外层和内层类型参数统一提升到代理类声明上
            var allTps = GetAllTypeParameters(cls);

            if (allTps.Count == 0) return string.Empty;
            return "<" + string.Join(", ", allTps.Select(tp => tp.Name)) + ">";
        }


        /// <summary>
        /// 构建代理类的类型参数约束部分 为所有提升的类型参数添加约束
        /// </summary>
        private static string BuildTypeParameterConstraints(INamedTypeSymbol cls)
        {
            // 为所有提升后的类型参数应用约束 包含外层类型的参数
            var allTps = GetAllTypeParameters(cls);

            if (allTps.Count == 0) return string.Empty;
            var sb = new StringBuilder();
            foreach (var tp in allTps)
            {
                var parts = new List<string>();

                // 先输出 primary 约束 值类型 结构体等
                if (tp.HasReferenceTypeConstraint) parts.Add("class");
                if (tp.HasUnmanagedTypeConstraint) parts.Add("unmanaged");
                if (tp.HasValueTypeConstraint) parts.Add("struct");
                if (tp.HasNotNullConstraint) parts.Add("notnull");

                // 然后输出具体的类型或接口约束
                foreach (var ct in tp.ConstraintTypes)
                {
                    parts.Add(ct.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                }

                // 最后输出 new() 约束
                if (tp.HasConstructorConstraint) parts.Add("new()");
                if (parts.Count > 0)
                {
                    sb.Append("    where ").Append(tp.Name).Append(" : ").Append(string.Join(", ", parts)).AppendLine();
                }
            }
            return sb.ToString();
        }


        /// <summary>
        /// 将 TypedConstant 安全地转换为 C# 源码中的字面量片段
        /// </summary>
        private static string? ToCSharpLiteral(TypedConstant c)
        {
            if (c.IsNull) return "null";
            if (c.Value is null) return null;
            if (c.Value is string s) return "\"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"";
            if (c.Value is bool b) return b ? "true" : "false";
            if (c.Value is char ch) return "'" + (ch == '\'' ? "\\'" : ch.ToString()) + "'";
            if (c.Type is INamedTypeSymbol nts && nts.TypeKind == TypeKind.Enum)
            {
                var named = nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                return named + "." + c.Value.ToString();
            }
            if (c.Value is IFormattable f) return f.ToString(null, System.Globalization.CultureInfo.InvariantCulture);
            return c.Value?.ToString();
        }


        /// <summary>
        /// 为给定类型生成适合作为 AddSource 提示名的安全字符串
        /// </summary>
        private static string GetSafeHintName(INamedTypeSymbol type)
        {
            var ns = type.ContainingNamespace.IsGlobalNamespace ? "global" : type.ContainingNamespace.ToDisplayString().Replace('.', '_');

            // 提示名中包含包含类型链及泛型个数和参数名 并避免使用特殊字符
            var parts = new List<string>();
            for (var t = type; t is not null; t = t.ContainingType)
            {
                var arity = t.TypeParameters.Length;
                var tpNames = arity > 0 ? "_" + string.Join("_", t.TypeParameters.Select(tp => tp.Name)) : string.Empty;
                var safeName = new string(t.Name.Select(ch => char.IsLetterOrDigit(ch) ? ch : '_').ToArray());
                var name = safeName + (arity > 0 ? "_g" + arity + tpNames : string.Empty);
                parts.Add(name);
            }
            parts.Reverse();
            return ns + "__" + string.Join("_", parts) + "__Proxy";
        }


        /// <summary>
        /// 收集包含类型链上的全部类型参数 按从外到内的顺序返回
        /// </summary>
        private static List<ITypeParameterSymbol> GetAllTypeParameters(INamedTypeSymbol type)
        {
            // 从最外层到最内层依次收集所有包含类型的类型参数
            var stack = new Stack<INamedTypeSymbol>();
            for (var t = type; t is not null; t = t.ContainingType)
                stack.Push(t);
            var list = new List<ITypeParameterSymbol>();
            foreach (var t in stack)
                list.AddRange(t.TypeParameters);
            return list;
        }


        /// <summary>
        /// 获取需要在代理类中生成显式实现的接口列表
        /// </summary>
        private static string[] GetInterfacesNeedingExplicitImplementations(INamedTypeSymbol cls)
        {
            var set = new HashSet<string>();
            foreach (var iface in cls.AllInterfaces)
            {
                foreach (var member in iface.GetMembers())
                {
                    switch (member)
                    {
                        case IMethodSymbol m:
                            if (m.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise)
                                continue;
                            var implM = cls.FindImplementationForInterfaceMember(m) as IMethodSymbol;
                            if (implM is not null && implM.ExplicitInterfaceImplementations.Length > 0) continue;
                            if (implM is not null && (implM.IsVirtual || implM.IsAbstract || implM.IsOverride)) continue;
                            set.Add(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                            break;
                        case IPropertySymbol p:
                            var implP = cls.FindImplementationForInterfaceMember(p) as IPropertySymbol;
                            if (implP is not null && implP.ExplicitInterfaceImplementations.Length > 0) continue;
                            if (implP is not null)
                            {
                                var gm = implP.GetMethod; var sm = implP.SetMethod;
                                if ((gm is not null && (gm.IsVirtual || gm.IsAbstract || gm.IsOverride)) ||
                                    (sm is not null && (sm.IsVirtual || sm.IsAbstract || sm.IsOverride)))
                                    break;
                            }
                            set.Add(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                            break;
                        case IEventSymbol e:
                            var implE = cls.FindImplementationForInterfaceMember(e) as IEventSymbol;
                            if (implE is not null && implE.ExplicitInterfaceImplementations.Length > 0) continue;
                            if (implE is not null)
                            {
                                var am = implE.AddMethod; var rm = implE.RemoveMethod;
                                if ((am is not null && (am.IsVirtual || am.IsAbstract || am.IsOverride)) ||
                                    (rm is not null && (rm.IsVirtual || rm.IsAbstract || rm.IsOverride)))
                                    break;
                            }
                            set.Add(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                            break;
                    }
                }
            }
            return set.ToArray();
        }
    }

}






