using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator.Core;

/// <summary>
/// 扫描继承自 Microsoft.Extensions.Hosting.BackgroundService 的类型
/// 为每个程序集生成注册后台服务的扩展方法
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class BackgroundServiceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 只关心类声明
        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is ClassDeclarationSyntax,
            static (syntaxContext, _) => syntaxContext.Node as ClassDeclarationSyntax
        );

        // 将类声明与编译对象组合，便于在输出阶段做语义分析
        var collected = classDeclarations.Collect().Combine(context.CompilationProvider);

        context.RegisterSourceOutput(collected, static (spc, tuple) =>
        {
            var (classNodes, compilation) = (tuple.Left, tuple.Right);

            var bgServiceSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.Hosting.BackgroundService");
            var hostedServiceSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.Hosting.IHostedService");
            var servicesSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.DependencyInjection.IServiceCollection");

            if (bgServiceSymbol is null || hostedServiceSymbol is null || servicesSymbol is null)
            {
                // 目标项目没有引用 Hosting，直接跳过
                return;
            }

            var registrations = new StringBuilder();

            foreach (var node in classNodes)
            {
                if (node is null)
                    continue;

                var model = compilation.GetSemanticModel(node.SyntaxTree);
                if (model.GetDeclaredSymbol(node) is not INamedTypeSymbol typeSymbol)
                    continue;

                // 只处理当前项目源码中的 public 非抽象类
                if (!typeSymbol.Locations.Any(l => l.IsInSource))
                    continue;
                if (typeSymbol.TypeKind != TypeKind.Class || typeSymbol.IsAbstract)
                    continue;
                if (typeSymbol.DeclaredAccessibility != Accessibility.Public)
                    continue;

                if (!InheritsFrom(typeSymbol, bgServiceSymbol))
                    continue;

                var implDisplay = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var call = BuildBackgroundRegistrationCall(implDisplay);
                registrations.Append("        ").AppendLine(call);
            }

            var assemblyName = compilation.AssemblyName ?? "Assembly";
            var safeAssemblyName = SanitizeIdentifier(assemblyName);
            var ns = "NetEngine.Generated";
            var extClassName = "ServiceCollectionExtensions";
            // 每个模块统一生成 RegisterBackgroundServices_{AssemblyName}
            var methodName = "RegisterBackgroundServices_" + safeAssemblyName;

            var isStartupLike = compilation.Options.OutputKind is OutputKind.ConsoleApplication
                                or OutputKind.WindowsApplication
                                or OutputKind.WindowsRuntimeApplication;

            // 对于既没有本地后台服务、又不是启动项目的情况，可以直接跳过。
            if (!isStartupLike && registrations.Length == 0)
                return;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();

            sb.Append("public static partial class ").Append(extClassName).AppendLine();
            sb.AppendLine("{");

            // 每个项目统一生成自己的 RegisterBackgroundServices_{AssemblyName} 扩展方法（仅在本程序集有后台服务时生成）
            if (registrations.Length > 0)
            {
                sb.Append("    public static IServiceCollection ")
                  .Append(methodName)
                  .AppendLine("(this IServiceCollection services)");
                sb.AppendLine("    {");
                sb.Append(registrations);
                sb.AppendLine("        return services;");
                sb.AppendLine("    }");
            }

            // 对于启动项目，额外生成一个聚合的 BatchRegisterBackgroundServices 方法，
            // 自动调用当前项目及所有引用项目的 RegisterBackgroundServices_{AssemblyName}。
            if (isStartupLike)
            {
                var methodNamesToInvoke = new System.Collections.Generic.List<string>();

                // 当前程序集如果有后台服务，则优先调用本地的 RegisterBackgroundServices_{AssemblyName}
                if (registrations.Length > 0)
                {
                    methodNamesToInvoke.Add(methodName);
                }

                foreach (var reference in compilation.References)
                {
                    if (compilation.GetAssemblyOrModuleSymbol(reference) is not IAssemblySymbol asm)
                        continue;

                    // 跳过自身程序集
                    if (string.Equals(asm.Name, assemblyName, StringComparison.Ordinal))
                        continue;

                    var extType = asm.GetTypeByMetadataName("NetEngine.Generated.ServiceCollectionExtensions");
                    if (extType is null)
                        continue;

                    var referencedSafeName = SanitizeIdentifier(asm.Name);
                    var refMethodName = "RegisterBackgroundServices_" + referencedSafeName;

                    var hasMethod = extType
                        .GetMembers(refMethodName)
                        .OfType<IMethodSymbol>()
                        .Any(m =>
                            m.IsStatic &&
                            m.IsExtensionMethod &&
                            m.Parameters.Length == 1 &&
                            SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, servicesSymbol));

                    if (hasMethod)
                    {
                        methodNamesToInvoke.Add(refMethodName);
                    }
                }

                sb.AppendLine();
                sb.AppendLine("    public static IServiceCollection BatchRegisterBackgroundServices(this IServiceCollection services)");
                sb.AppendLine("    {");
                foreach (var name in methodNamesToInvoke)
                {
                    sb.Append("        services.").Append(name).AppendLine("();");
                }
                sb.AppendLine("        return services;");
                sb.AppendLine("    }");
            }
            sb.AppendLine("}");

            var hintName = $"{safeAssemblyName}_BackgroundServices_Register.g.cs";
            spc.AddSource(hintName, sb.ToString());
        });
    }

    private static bool InheritsFrom(INamedTypeSymbol type, INamedTypeSymbol baseType)
    {
        for (var current = type.BaseType; current is not null; current = current.BaseType)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
        }
        return false;
    }

    private static string BuildBackgroundRegistrationCall(string implDisplay)
    {
        // 使用 services.AddHostedService<Impl>() 语法注册后台服务
        var sb = new StringBuilder("services.AddHostedService");
        sb.Append("<").Append(implDisplay).Append(">();");
        return sb.ToString();
    }

    private static string SanitizeIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name))
            return "_";

        var builder = new StringBuilder(name.Length);
        if (!SyntaxFacts.IsIdentifierStartCharacter(name[0]))
        {
            builder.Append('_');
        }

        foreach (var ch in name)
        {
            builder.Append(SyntaxFacts.IsIdentifierPartCharacter(ch) ? ch : '_');
        }

        return builder.ToString();
    }
}

