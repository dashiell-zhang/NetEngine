using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator.Core;

/// <summary>
/// 根据 RegisterServiceAttribute 生成 DI 注册扩展方法
/// 每个项目独立生成一份
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class RegisterServiceGenerator : IIncrementalGenerator
{
    private const string RegisterServiceAttributeMetadataName = "SourceGenerator.Runtime.Attributes.RegisterServiceAttribute";

    private sealed class ServiceCandidate
    {
        public INamedTypeSymbol Type { get; }
        public AttributeData Attribute { get; }

        public ServiceCandidate(INamedTypeSymbol type, AttributeData attribute)
        {
            Type = type;
            Attribute = attribute;
        }
    }

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var candidates = context.SyntaxProvider.ForAttributeWithMetadataName(
            RegisterServiceAttributeMetadataName,
            static (node, _) => node is ClassDeclarationSyntax,
            static (syntaxContext, _) =>
                new ServiceCandidate(
                    (INamedTypeSymbol)syntaxContext.TargetSymbol!,
                    syntaxContext.Attributes[0])
        );

        // 收集本次编译中所有 [RegisterService] 目标
        var collected = candidates.Collect().Combine(context.CompilationProvider);

        context.RegisterSourceOutput(collected, static (spc, tuple) =>
        {
            var (serviceCandidates, compilation) = (tuple.Left, tuple.Right);

            var servicesSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.DependencyInjection.IServiceCollection");
            if (servicesSymbol is null)
                return;

            var registrations = new StringBuilder();

            foreach (var candidate in serviceCandidates)
            {
                var typeSymbol = candidate.Type;

                // 只处理当前项目源码中的类型，避免跨项目“公共库”被自动注册
                if (!typeSymbol.Locations.Any(l => l.IsInSource))
                    continue;

                if (typeSymbol.TypeKind != TypeKind.Class || typeSymbol.IsAbstract)
                    continue;

                var attrData = candidate.Attribute;
                var lifetime = GetLifetime(attrData) ?? "Transient";
                var keyExpr = GetKeyExpression(attrData);

                var iface = typeSymbol.AllInterfaces.FirstOrDefault();
                var typeDisplay = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var ifaceDisplay = iface?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                var call = BuildRegistrationCall(lifetime, keyExpr, ifaceDisplay, typeDisplay);
                registrations.Append("        ").AppendLine(call);
            }

            var assemblyName = compilation.AssemblyName ?? "Assembly";
            var safeAssemblyName = SanitizeIdentifier(assemblyName);
            // 命名空间统一为 NetEngine.Generated，通过不同的方法名区分不同程序集：
            // RegisterServices_{AssemblyName}
            var ns = "NetEngine.Generated";
            var extClassName = "ServiceCollectionExtensions";
            var methodName = "RegisterServices_" + safeAssemblyName;

            var isStartupLike = compilation.Options.OutputKind is OutputKind.ConsoleApplication
                                or OutputKind.WindowsApplication
                                or OutputKind.WindowsRuntimeApplication;

            // 对于既没有本地注册、又不是启动项目的情况，可以直接跳过。
            if (!isStartupLike && registrations.Length == 0)
                return;

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();

            sb.Append("public static partial class ").Append(extClassName).AppendLine();
            sb.AppendLine("{");

            // 每个项目统一生成自己的 Add{Assembly}RegisterServices 扩展方法
            sb.Append("    public static Microsoft.Extensions.DependencyInjection.IServiceCollection ")
              .Append(methodName)
              .AppendLine("(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
            sb.AppendLine("    {");
            sb.Append(registrations);
            sb.AppendLine("        return services;");
            sb.AppendLine("    }");

            // 对于启动项目，额外生成一个聚合的 BatchRegisterServices 方法，
            // 自动调用当前项目及所有引用项目的 RegisterServices_{AssemblyName}。
            if (isStartupLike)
            {
                var methodNamesToInvoke = new System.Collections.Generic.List<string>
                {
                    methodName
                };

                foreach (var reference in compilation.References)
                {
                    if (compilation.GetAssemblyOrModuleSymbol(reference) is not IAssemblySymbol asm)
                        continue;

                    // 跳过自身程序集
                    if (string.Equals(asm.Name, assemblyName, StringComparison.Ordinal))
                        continue;

                    var extType = asm.GetTypeByMetadataName("NetEngine.Generated.ServiceCollectionExtensions");
                    if (extType is null)
                        continue;

                    var referencedSafeName = SanitizeIdentifier(asm.Name);
                    var refMethodName = "RegisterServices_" + referencedSafeName;

                    var hasMethod = extType
                        .GetMembers(refMethodName)
                        .OfType<IMethodSymbol>()
                        .Any(m =>
                            m.IsStatic &&
                            m.IsExtensionMethod &&
                            m.Parameters.Length == 1 &&
                            SymbolEqualityComparer.Default.Equals(m.Parameters[0].Type, servicesSymbol));

                    if (hasMethod)
                    {
                        methodNamesToInvoke.Add(refMethodName);
                    }
                }

                sb.AppendLine();
                sb.AppendLine("    public static Microsoft.Extensions.DependencyInjection.IServiceCollection BatchRegisterServices(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
                sb.AppendLine("    {");
                foreach (var name in methodNamesToInvoke)
                {
                    sb.Append("        services.").Append(name).AppendLine("();");
                }
                sb.AppendLine("        return services;");
                sb.AppendLine("    }");
            }

            sb.AppendLine("}");

            var hintName = $"{extClassName}_RegisterServices.g.cs";
            spc.AddSource(hintName, sb.ToString());
        });
    }

    private static string BuildRegistrationCall(string lifetime, string? keyExpr, string? ifaceDisplay, string implDisplay)
    {
        var hasInterface = !string.IsNullOrWhiteSpace(ifaceDisplay);
        var hasKey = !string.IsNullOrWhiteSpace(keyExpr);

        var sb = new StringBuilder("global::Microsoft.Extensions.DependencyInjection.");

        if (!hasKey)
        {
            sb.Append(lifetime switch
            {
                "Singleton" => "ServiceCollectionServiceExtensions.AddSingleton",
                "Scoped" => "ServiceCollectionServiceExtensions.AddScoped",
                _ => "ServiceCollectionServiceExtensions.AddTransient"
            });

            if (hasInterface)
            {
                sb.Append("<").Append(ifaceDisplay).Append(", ").Append(implDisplay).Append(">(services);");
            }
            else
            {
                sb.Append("<").Append(implDisplay).Append(">(services);");
            }
        }
        else
        {
            sb.Append(lifetime switch
            {
                "Singleton" => "ServiceCollectionServiceExtensions.AddKeyedSingleton",
                "Scoped" => "ServiceCollectionServiceExtensions.AddKeyedScoped",
                _ => "ServiceCollectionServiceExtensions.AddKeyedTransient"
            });

            if (hasInterface)
            {
                // AddKeyedXxx<TService, TImplementation>(services, key)
                sb.Append("<").Append(ifaceDisplay).Append(", ").Append(implDisplay).Append(">(services, ").Append(keyExpr).Append(");");
            }
            else
            {
                // AddKeyedXxx<TService>(services, key)
                sb.Append("<").Append(implDisplay).Append(">(services, ").Append(keyExpr).Append(");");
            }
        }

        return sb.ToString();
    }

    private static string? GetLifetime(AttributeData attr)
    {
        foreach (var pair in attr.NamedArguments)
        {
            var key = pair.Key;
            var value = pair.Value;

            if (key == "Lifetime" && value.Value is int enumValue)
            {
                // ServiceLifetime enum: 0 Singleton, 1 Scoped, 2 Transient
                return enumValue switch
                {
                    0 => "Singleton",
                    1 => "Scoped",
                    _ => "Transient"
                };
            }
        }

        return null;
    }

    private static string? GetKeyExpression(AttributeData attr)
    {
        foreach (var pair in attr.NamedArguments)
        {
            if (pair.Key != "Key")
                continue;

            var typedConstant = pair.Value;

            // 显式为 null，则视为没有 Key
            if (typedConstant.Value is null)
                return null;

            // 使用 Roslyn 自带的 ToCSharpString 生成常量/typeof/枚举等表达式，
            // 这样可以支持 string、数字、bool、enum、typeof(...) 等所有合法属性值。
            var expr = typedConstant.ToCSharpString();

            // 保险起见，防止出现字面量 "null"
            if (string.Equals(expr, "null", StringComparison.Ordinal))
                return null;

            return expr;
        }

        return null;
    }

    private static string SanitizeIdentifier(string name)
    {
        var builder = new StringBuilder(name.Length);
        if (name.Length == 0)
            return "_";

        if (!SyntaxFacts.IsIdentifierStartCharacter(name[0]))
        {
            builder.Append('_');
        }

        foreach (var ch in name)
        {
            builder.Append(SyntaxFacts.IsIdentifierPartCharacter(ch) ? ch : '_');
        }

        return builder.ToString();
    }
}
