using System;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace SourceGenerator.Core;

/// <summary>
/// 扫描继承自 Microsoft.Extensions.Hosting.BackgroundService 的类型，
/// 为每个程序集生成注册后台服务的扩展方法。
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class BackgroundServiceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 只关心类声明
        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is ClassDeclarationSyntax,
            static (syntaxContext, _) => syntaxContext.Node as ClassDeclarationSyntax
        );

        // 将类声明与编译对象组合，便于在输出阶段做语义分析
        var collected = classDeclarations.Collect().Combine(context.CompilationProvider);

        context.RegisterSourceOutput(collected, static (spc, tuple) =>
        {
            var (classNodes, compilation) = (tuple.Left, tuple.Right);

            var bgServiceSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.Hosting.BackgroundService");
            var hostedServiceSymbol = compilation.GetTypeByMetadataName("Microsoft.Extensions.Hosting.IHostedService");

            if (bgServiceSymbol is null || hostedServiceSymbol is null)
            {
                // 目标项目没有引用 Hosting，直接跳过
                return;
            }

            var registrations = new StringBuilder();

            foreach (var node in classNodes)
            {
                if (node is null)
                    continue;

                var model = compilation.GetSemanticModel(node.SyntaxTree);
                if (model.GetDeclaredSymbol(node) is not INamedTypeSymbol typeSymbol)
                    continue;

                // 只处理当前项目源码中的 public 非抽象类
                if (!typeSymbol.Locations.Any(l => l.IsInSource))
                    continue;
                if (typeSymbol.TypeKind != TypeKind.Class || typeSymbol.IsAbstract)
                    continue;
                if (typeSymbol.DeclaredAccessibility != Accessibility.Public)
                    continue;

                if (!InheritsFrom(typeSymbol, bgServiceSymbol))
                    continue;

                var implDisplay = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var call = BuildBackgroundRegistrationCall(implDisplay);
                registrations.Append("        ").AppendLine(call);
            }

            if (registrations.Length == 0)
                return;

            var assemblyName = compilation.AssemblyName ?? "Assembly";
            var safeAssemblyName = SanitizeIdentifier(assemblyName);
            var ns = "NetEngine.Generated";
            var extClassName = "ServiceCollectionExtensions";
            var methodName = "Add" + safeAssemblyName + "BackgroundServices";

            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("#nullable enable");
            sb.Append("namespace ").Append(ns).AppendLine(";");
            sb.AppendLine();

            sb.Append("public static partial class ").Append(extClassName).AppendLine();
            sb.AppendLine("{");
            sb.Append("    public static Microsoft.Extensions.DependencyInjection.IServiceCollection ")
              .Append(methodName)
              .AppendLine("(this Microsoft.Extensions.DependencyInjection.IServiceCollection services)");
            sb.AppendLine("    {");
            sb.Append(registrations);
            sb.AppendLine("        return services;");
            sb.AppendLine("    }");
            sb.AppendLine("}");

            var hintName = $"{safeAssemblyName}_BackgroundServices_Register.g.cs";
            spc.AddSource(hintName, sb.ToString());
        });
    }

    private static bool InheritsFrom(INamedTypeSymbol type, INamedTypeSymbol baseType)
    {
        for (var current = type.BaseType; current is not null; current = current.BaseType)
        {
            if (SymbolEqualityComparer.Default.Equals(current, baseType))
                return true;
        }
        return false;
    }

    private static string BuildBackgroundRegistrationCall(string implDisplay)
    {
        // 等价于 services.AddSingleton<IHostedService, Impl>();
        var sb = new StringBuilder("global::Microsoft.Extensions.DependencyInjection.ServiceCollectionServiceExtensions.AddSingleton");
        sb.Append("<global::Microsoft.Extensions.Hosting.IHostedService, ").Append(implDisplay).Append(">(services);");
        return sb.ToString();
    }

    private static string SanitizeIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name))
            return "_";

        var builder = new StringBuilder(name.Length);
        if (!SyntaxFacts.IsIdentifierStartCharacter(name[0]))
        {
            builder.Append('_');
        }

        foreach (var ch in name)
        {
            builder.Append(SyntaxFacts.IsIdentifierPartCharacter(ch) ? ch : '_');
        }

        return builder.ToString();
    }
}

