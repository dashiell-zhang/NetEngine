using SourceGenerator.Core.Internal;
using Microsoft.CodeAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace SourceGenerator.Core;

internal sealed class ClassProxyHandler
{
    private const string ProxyBehaviorAttributeMetadataName = "SourceGenerator.Runtime.Attributes.ProxyBehaviorAttribute";

    public bool CanHandle(INamedTypeSymbol type, AttributeData? attribute)
        => type.TypeKind == TypeKind.Class
           && type.Constructors.Any(c => c.DeclaredAccessibility == Accessibility.Public);

    public void Execute(in HandlerContext ctx)
    {
        var src = GenerateDerivedProxy(ctx.Type);
        var hint = GetSafeHintName(ctx.Type) + ".g.cs";
        ctx.Context.AddSource(hint, src);
    }

    private static string GenerateDerivedProxy(INamedTypeSymbol cls)
    {
        var ns = cls.ContainingNamespace.IsGlobalNamespace
            ? "NetEngine.Generated"
            : cls.ContainingNamespace.ToDisplayString();

        // Fully qualified name with and without global:: prefix
        var classFullFq = cls.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var classFull = classFullFq.Replace("global::", string.Empty);
        var proxyName = cls.Name + "_Proxy";
        var typeParamsDecl = BuildTypeParametersDecl(cls);
        var typeParamConstraints = BuildTypeParameterConstraints(cls);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();


        // proxy class derives from original implementation; only list interfaces that we will explicitly implement in this proxy
        var minimalInterfaces = GetInterfacesNeedingExplicitImplementations(cls);
        var ifaceList = minimalInterfaces.Length == 0 ? string.Empty : ", " + string.Join(", ", minimalInterfaces);
        // Derive from fully-qualified base type to avoid resolution issues, especially for global namespace or nested types
        sb.Append("public sealed class ").Append(proxyName).Append(typeParamsDecl).Append(" : ").Append(classFullFq).Append(ifaceList).AppendLine();
        if (!string.IsNullOrWhiteSpace(typeParamConstraints)) sb.Append(typeParamConstraints);
        sb.AppendLine("{")
          .AppendLine("    private readonly global::System.IServiceProvider? __sp;")
          .AppendLine();

        // constructors: mirror base public/protected ctors; also add overloads with IServiceProvider if not already leading
        foreach (var ctor in cls.Constructors)
        {
            // Only support DI-friendly public constructors
            if (ctor.DeclaredAccessibility != Accessibility.Public)
                continue;

            var paramList = string.Join(", ", ctor.Parameters.Select(p => FormatParameter(p, includeDefault: true)));
            var argList = string.Join(", ", ctor.Parameters.Select(p => p.Name));
            // plain mirror
            sb.Append("    public ").Append(proxyName).Append('(').Append(paramList).Append(')').AppendLine()
              .AppendLine("        : base(" + argList + ")")
              .AppendLine("    {")
              .AppendLine("    }")
              .AppendLine();

            // IServiceProvider-leading overload if first param is not IServiceProvider
            var firstIsSp = ctor.Parameters.FirstOrDefault() is IParameterSymbol fp && IsType(fp.Type, "System.IServiceProvider");
            if (!firstIsSp)
            {
                var withSpParams = (ctor.Parameters.Length == 0)
                    ? "global::System.IServiceProvider sp"
                    : "global::System.IServiceProvider sp, " + paramList;
                sb.Append("    public ").Append(proxyName).Append('(').Append(withSpParams).Append(')').AppendLine()
                  .AppendLine("        : base(" + argList + ")")
                  .AppendLine("    {")
                  .AppendLine("        __sp = sp;")
                  .AppendLine("    }")
                  .AppendLine();
            }
        }

        // override virtual/abstract public instance methods
        foreach (var method in cls.GetMembers().OfType<IMethodSymbol>())
        {
            if (method.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise or MethodKind.StaticConstructor or MethodKind.Constructor)
                continue;
            if (method.DeclaredAccessibility != Accessibility.Public || method.IsStatic)
                continue;
            if (!(method.IsVirtual || method.IsAbstract || method.IsOverride))
                continue;
            AppendDerivedOverride(sb, method, classFull, callTarget: "base");
        }

        // explicit interface implementations to intercept when used via interface
        foreach (var iface in cls.AllInterfaces)
        {
            foreach (var member in iface.GetMembers())
            {
                switch (member)
                {
                    case IMethodSymbol m:
                        if (m.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise)
                            continue;
                        // find implementation in class
                        var impl = cls.FindImplementationForInterfaceMember(m) as IMethodSymbol;
                        // If the implementation in the hierarchy is an explicit interface implementation,
                        // we cannot forward using base.Method(...). Skip generating to avoid compile-time errors.
                        if (impl is not null && impl.ExplicitInterfaceImplementations.Length > 0)
                            break;
                        // If the implementation is already overridable, the override path will intercept calls even via interface dispatch.
                        // In that case, generating explicit implementation is redundant; skip it to avoid re-listing the interface.
                        if (impl is not null && (impl.IsVirtual || impl.IsAbstract || impl.IsOverride))
                            break;
                        AppendExplicitInterfaceMethod(sb, iface, m, impl, classFull);
                        break;
                    case IPropertySymbol p:
                        {
                            var implProp = cls.FindImplementationForInterfaceMember(p) as IPropertySymbol;
                            if (implProp is not null && implProp.ExplicitInterfaceImplementations.Length > 0)
                                break;
                            // If either accessor is overridable, the override path suffices.
                            if (implProp is not null)
                            {
                                var gm = implProp.GetMethod; var sm = implProp.SetMethod;
                                if ((gm is not null && (gm.IsVirtual || gm.IsAbstract || gm.IsOverride)) ||
                                    (sm is not null && (sm.IsVirtual || sm.IsAbstract || sm.IsOverride)))
                                    break;
                            }
                            AppendExplicitInterfaceProperty(sb, iface, p, cls);
                        }
                        break;
                    case IEventSymbol e:
                        {
                            var implEv = cls.FindImplementationForInterfaceMember(e) as IEventSymbol;
                            if (implEv is not null && implEv.ExplicitInterfaceImplementations.Length > 0)
                                break;
                            // If either accessor is overridable, override path suffices.
                            if (implEv is not null)
                            {
                                var am = implEv.AddMethod; var rm = implEv.RemoveMethod;
                                if ((am is not null && (am.IsVirtual || am.IsAbstract || am.IsOverride)) ||
                                    (rm is not null && (rm.IsVirtual || rm.IsAbstract || rm.IsOverride)))
                                    break;
                            }
                            AppendExplicitInterfaceEvent(sb, iface, e, cls);
                        }
                        break;
                }
            }
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static void AppendDerivedOverride(StringBuilder sb, IMethodSymbol method, string typeFullName, string callTarget)
    {
        var isGenericTask = method.ReturnType is INamedTypeSymbol nts && nts.IsGenericType && IsType(nts.ConstructedFrom, "System.Threading.Tasks.Task");
        var isTask = method.ReturnType is INamedTypeSymbol nts0 && !nts0.IsGenericType && IsType(nts0, "System.Threading.Tasks.Task");
        var isGenericValueTask = method.ReturnType is INamedTypeSymbol nts2 && nts2.IsGenericType && IsType(nts2.ConstructedFrom, "System.Threading.Tasks.ValueTask");
        var isValueTask = method.ReturnType is INamedTypeSymbol nts3 && !nts3.IsGenericType && IsType(nts3, "System.Threading.Tasks.ValueTask");
        var isAsyncEnumerable = (method.ReturnType is INamedTypeSymbol nts4 && nts4.IsGenericType && IsType(nts4.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable"))
            || method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal);
        var isTaskOfAsyncEnumerable = isGenericTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t1 && (
            (t1.IsGenericType && IsType(t1.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
            t1.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));
        var isValueTaskOfAsyncEnumerable = isGenericValueTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t2 && (
            (t2.IsGenericType && IsType(t2.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
            t2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));
        if (!isTaskOfAsyncEnumerable)
        {
            var rtText2 = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (rtText2.StartsWith("global::System.Threading.Tasks.Task<global::System.Collections.Generic.IAsyncEnumerable<", StringComparison.Ordinal))
                isTaskOfAsyncEnumerable = true;
        }
        if (!isValueTaskOfAsyncEnumerable)
        {
            var rtText2 = method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (rtText2.StartsWith("global::System.Threading.Tasks.ValueTask<global::System.Collections.Generic.IAsyncEnumerable<", StringComparison.Ordinal))
                isValueTaskOfAsyncEnumerable = true;
        }

        var returnType = method.ReturnType
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var methodName = method.Name;
        var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
        var paramList = string.Join(", ", method.Parameters.Select(p => FormatParameter(p, includeDefault: false)));
        var argList = string.Join(", ", method.Parameters.Select(p => (p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty) + p.Name + (p.RefKind == RefKind.None ? "!" : string.Empty)));

        var isByRefReturn = method.ReturnsByRef || method.ReturnsByRefReadonly;
        var hasByRefAny = isByRefReturn || method.Parameters.Any(p => p.RefKind != RefKind.None || p.Type.IsRefLikeType);
        var needsAsync = hasByRefAny && (isTask || isGenericTask || isValueTask || isGenericValueTask);
        var sigReturnType = method.ReturnsVoid
            ? "void"
            : isByRefReturn
                ? (method.ReturnsByRefReadonly ? "ref readonly " : "ref ") + returnType
                : returnType;

        sb.Append("    public override ").Append(needsAsync ? "async " : string.Empty).Append(sigReturnType).Append(' ').Append(methodName).Append(typeParams)
          .Append('(').Append(paramList).Append(')').AppendLine()
          .AppendLine("    {");

        if (method.Parameters.Length > 0)
        {
            sb.AppendLine("        var __argsDict = new global::System.Collections.Generic.Dictionary<string, string?>(" + method.Parameters.Length + ");");
            foreach (var p in method.Parameters)
            {
                var isOut = p.RefKind == RefKind.Out;
                var isRefLike = p.Type.IsRefLikeType;
                if (isOut || isRefLike)
                {
                    sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = null;").AppendLine();
                }
                else
                {
                    if (TryGetSkipPlaceholder(p.Type, out var __ph))
                    {
                        sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = \"")
                          .Append(__ph.Replace("\\", "\\\\").Replace("\"", "\\\"") )
                          .Append("\";").AppendLine();
                    }
                    else
                    {
                        sb.Append("        try { __argsDict[\"").Append(p.Name).Append("\"] = global::SourceGenerator.Runtime.JsonUtil.ToJson(")
                          .Append(p.Name).Append("); } catch { __argsDict[\"").Append(p.Name).Append("\"] = global::System.Convert.ToString(")
                          .Append(p.Name).Append("); }").AppendLine();
                    }
                }
            }
            sb.AppendLine("        object? __argsObj = __argsDict;");
        }
        else
        {
            sb.AppendLine("        object? __argsObj = null;");
        }

        sb.AppendLine("        var __logMethod = \"" + typeFullName + "\" + \"." + methodName + "\";");
        sb.AppendLine("        var __logger = (__sp?.GetService(typeof(global::Microsoft.Extensions.Logging.ILoggerFactory)) as global::Microsoft.Extensions.Logging.ILoggerFactory)?.CreateLogger(\"SourceGenerator.Runtime.ProxyRuntime\");");

        var hasByRef = hasByRefAny;
        var behaviorSnippets = new List<string> { "new global::SourceGenerator.Runtime.Pipeline.Behaviors.LoggingBehavior()" };
        var optionsSetters = new List<string>();
        foreach (var a in method.GetAttributes())
        {
            if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
            {
                var include = !hasByRef || CanUseAsFilter(a);
                if (include)
                {
                    behaviorSnippets.Add($"new {behaviorFull}()");
                    if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                }
            }
        }
        sb.AppendLine("        var __behaviors = new global::SourceGenerator.Runtime.Pipeline.IInvocationAsyncBehavior[] { " + string.Join(", ", behaviorSnippets) + " };");
        var __hasReturn = isGenericTask || isGenericValueTask || (!isTask && !isValueTask && !method.ReturnsVoid) || isAsyncEnumerable;
        var __allowRet = __hasReturn && IsAllowReturnSerialization(method);
        sb.AppendLine("        var __ctx = new global::SourceGenerator.Runtime.Pipeline.InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = global::System.Guid.CreateVersion7(), Log = true, HasReturnValue = " + (__hasReturn ? "true" : "false") + ", AllowReturnSerialization = " + (__allowRet ? "true" : "false") + ", ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
        if (optionsSetters.Count > 0) sb.AppendLine("        " + string.Join("\n        ", optionsSetters));

        if (hasByRef || isAsyncEnumerable || isTaskOfAsyncEnumerable || isValueTaskOfAsyncEnumerable)
        {
            sb.AppendLine("        var __filters = new global::System.Collections.Generic.List<global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior>();");
            sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior __f) __filters.Add(__f); }");
            if (isAsyncEnumerable)
            {
                // stream wrapper around enumeration; collect per-item JSON and log aggregated result after completion
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                var callExpr = callTarget + "." + methodName + typeParams + "(" + argList + ")";
                sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __e = {callExpr}.GetAsyncEnumerator();");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                while (true)");
                sb.AppendLine("                {");
                sb.AppendLine("                    bool __moved;");
                sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("                    if (!__moved) break;");
                sb.AppendLine("                    var __item = __e.Current;");
                sb.AppendLine("                    try { __items.Add(global::SourceGenerator.Runtime.JsonUtil.ToObject(global::SourceGenerator.Runtime.JsonUtil.ToJson(__item))); } catch { __items.Add(global::System.Convert.ToString(__item)); }");
                sb.AppendLine("                    yield return __item;");
                sb.AppendLine("                }");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                await __e.DisposeAsync();");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine($"        return __streamWrapper();");
                sb.AppendLine("    }");
                return; // early return from method codegen since we emitted body
            }
            if (isTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            await {callTarget}.{methodName}{typeParams}({argList});");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isTaskOfAsyncEnumerable)
            {
                var tItem = (((INamedTypeSymbol)((INamedTypeSymbol)method.ReturnType).TypeArguments[0]).TypeArguments[0])
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                var callExpr = callTarget + "." + methodName + typeParams + "(" + argList + ")";
                sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tItem}> __streamWrapper(){{");
                sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __s = await {callExpr};");
                sb.AppendLine("            var __e = __s.GetAsyncEnumerator();");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                while (true)");
                sb.AppendLine("                {");
                sb.AppendLine("                    bool __moved;");
                sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("                    if (!__moved) break;");
                sb.AppendLine("                    var __item = __e.Current;");
                sb.AppendLine("                    try { __items.Add(global::SourceGenerator.Runtime.JsonUtil.ToObject(global::SourceGenerator.Runtime.JsonUtil.ToJson(__item))); } catch { __items.Add(global::System.Convert.ToString(__item)); }");
                sb.AppendLine("                    yield return __item;");
                sb.AppendLine("                }");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                await __e.DisposeAsync();");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine($"        return global::System.Threading.Tasks.Task.FromResult<global::System.Collections.Generic.IAsyncEnumerable<{tItem}>>(__streamWrapper());");
            }
            else if (isGenericTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __res = await {callTarget}.{methodName}{typeParams}({argList});");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                sb.AppendLine("            return __res;");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isValueTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            await {callTarget}.{methodName}{typeParams}({argList});");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                sb.AppendLine("            return;");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isGenericValueTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __res = await {callTarget}.{methodName}{typeParams}({argList});");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                sb.AppendLine("            return __res;");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isByRefReturn)
            {
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); ref var __ret = ref " + callTarget + "." + methodName + typeParams + "(" + argList + "); var __snap = __ret; foreach (var __f in __filters) __f.OnAfter(__ctx, __snap); return ref __ret; } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
            }
            else if (method.ReturnsVoid)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); " + callTarget + "." + methodName + typeParams + "(" + argList + "); " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("        return;");
            }
            else
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); var __ret = " + callTarget + "." + methodName + typeParams + "(" + argList + "); " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __ret); return __ret; } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
            }
        }
        else
        {
            if (isAsyncEnumerable)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                var callExpr = callTarget + "." + methodName + typeParams + "(" + argList + ")";
                sb.AppendLine($"        var __behaviors = new global::SourceGenerator.Runtime.Pipeline.IInvocationAsyncBehavior[] {{ new global::SourceGenerator.Runtime.Pipeline.Behaviors.LoggingBehavior() }};")
                  .AppendLine("        var __ctx = new global::SourceGenerator.Runtime.Pipeline.InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = global::System.Guid.CreateVersion7(), Log = true, HasReturnValue = true, AllowReturnSerialization = true, ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
                sb.AppendLine("        var __filters = new global::System.Collections.Generic.List<global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior>();");
                sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior __f) __filters.Add(__f); }");
                sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __e = {callExpr}.GetAsyncEnumerator();");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                while (true)");
                sb.AppendLine("                {");
                sb.AppendLine("                    bool __moved;");
                sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("                    if (!__moved) break;");
                sb.AppendLine("                    var __item = __e.Current;");
                sb.AppendLine("                    try { __items.Add(global::SourceGenerator.Runtime.JsonUtil.ToObject(global::SourceGenerator.Runtime.JsonUtil.ToJson(__item))); } catch { __items.Add(global::System.Convert.ToString(__item)); }");
                sb.AppendLine("                    yield return __item;");
                sb.AppendLine("                }");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                await __e.DisposeAsync();");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine($"        return __streamWrapper();");
                sb.AppendLine("    }");
                return;
            }

            var runtime = "global::SourceGenerator.Runtime.ProxyRuntime";
            if (isTask)
            {
                sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
            }
            else if (isGenericTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
            }
            else if (isValueTask)
            {
                sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
            }
            else if (isGenericValueTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}) );");
            }
            else if (method.ReturnsVoid)
            {
                sb.AppendLine($"        {runtime}.Execute<object?>(__ctx, () => {{ {callTarget}.{methodName}{typeParams}({argList}); return global::System.Threading.Tasks.ValueTask.FromResult<object?>(null); }});");
                sb.AppendLine("        return;");
            }
            else
            {
                // Fallback guard: if compile-time detection missed Task/Task<T>, switch based on returnType text
                if (returnType.StartsWith("global::System.Threading.Tasks.Task<", StringComparison.Ordinal))
                {
                    var tArgText = returnType.Substring("global::System.Threading.Tasks.Task<".Length);
                    tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                }
                else if (string.Equals(returnType, "global::System.Threading.Tasks.Task", StringComparison.Ordinal))
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                }
                // Fallback guard: if compile-time detection missed ValueTask/ValueTask<T>, switch based on returnType text
                else if (returnType.StartsWith("global::System.Threading.Tasks.ValueTask<", StringComparison.Ordinal))
                {
                    var tArgText = returnType.Substring("global::System.Threading.Tasks.ValueTask<".Length);
                    tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}) );");
                }
                else if (string.Equals(returnType, "global::System.Threading.Tasks.ValueTask", StringComparison.Ordinal))
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {callTarget}.{methodName}{typeParams}({argList}));");
                }
                else
                {
                    sb.AppendLine($"        return {runtime}.Execute<{returnType}>(__ctx, () => global::System.Threading.Tasks.ValueTask.FromResult({callTarget}.{methodName}{typeParams}({argList})));");
                }
            }
        }

        sb.AppendLine("    }");
    }

    private static void AppendExplicitInterfaceMethod(StringBuilder sb, INamedTypeSymbol iface, IMethodSymbol method, IMethodSymbol? impl, string typeFullName)
    {
        // Build compile-time behaviors from both interface method and implementation method attributes
        var isGenericTask = method.ReturnType is INamedTypeSymbol nts && nts.IsGenericType && IsType(nts.ConstructedFrom, "System.Threading.Tasks.Task");
        var isTask = method.ReturnType is INamedTypeSymbol nts0 && !nts0.IsGenericType && IsType(nts0, "System.Threading.Tasks.Task");
        var isGenericValueTask = method.ReturnType is INamedTypeSymbol nts2 && nts2.IsGenericType && IsType(nts2.ConstructedFrom, "System.Threading.Tasks.ValueTask");
        var isValueTask = method.ReturnType is INamedTypeSymbol nts3 && !nts3.IsGenericType && IsType(nts3, "System.Threading.Tasks.ValueTask");
        var isAsyncEnumerable = (method.ReturnType is INamedTypeSymbol nts4 && nts4.IsGenericType && IsType(nts4.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable"))
            || method.ReturnType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal);
        var isTaskOfAsyncEnumerable = isGenericTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t1 && (
            (t1.IsGenericType && IsType(t1.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
            t1.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));
        var isValueTaskOfAsyncEnumerable = isGenericValueTask && ((INamedTypeSymbol)method.ReturnType).TypeArguments[0] is INamedTypeSymbol t2 && (
            (t2.IsGenericType && IsType(t2.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable")) ||
            t2.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", System.StringComparison.Ordinal));

        var returnType = method.ReturnType
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var ifaceDisplay = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var methodName = method.Name;
        var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
        var paramList = string.Join(", ", method.Parameters.Select(p => FormatParameter(p, includeDefault: false)));
        var argList = string.Join(", ", method.Parameters.Select(p => (p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty) + p.Name + (p.RefKind == RefKind.None ? "!" : string.Empty)));

        var isByRefReturn = method.ReturnsByRef || method.ReturnsByRefReadonly;
        var hasByRef2_head = isByRefReturn || method.Parameters.Any(p => p.RefKind != RefKind.None || p.Type.IsRefLikeType);
        var needsAsync2 = hasByRef2_head && (isTask || isGenericTask || isValueTask || isGenericValueTask);
        var sigReturnType = method.ReturnsVoid
            ? "void"
            : isByRefReturn
                ? (method.ReturnsByRefReadonly ? "ref readonly " : "ref ") + returnType
                : returnType;

        sb.Append("    ").Append(needsAsync2 ? "async " : string.Empty).Append(sigReturnType).Append(' ').Append(ifaceDisplay).Append('.').Append(methodName).Append(typeParams)
          .Append('(').Append(paramList).Append(')').AppendLine()
          .AppendLine("    {");

        if (method.Parameters.Length > 0)
        {
            sb.AppendLine("        var __argsDict = new global::System.Collections.Generic.Dictionary<string, string?>(" + method.Parameters.Length + ");");
            foreach (var p in method.Parameters)
            {
                var isOut = p.RefKind == RefKind.Out;
                var isRefLike = p.Type.IsRefLikeType;
                if (isOut || isRefLike)
                {
                    sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = null;").AppendLine();
                }
                else
                {
                    if (TryGetSkipPlaceholder(p.Type, out var __ph))
                    {
                        sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = \"")
                          .Append(__ph.Replace("\\", "\\\\").Replace("\"", "\\\"") )
                          .Append("\";").AppendLine();
                    }
                    else
                    {
                        sb.Append("        try { __argsDict[\"").Append(p.Name).Append("\"] = global::SourceGenerator.Runtime.JsonUtil.ToJson(")
                          .Append(p.Name).Append("); } catch { __argsDict[\"").Append(p.Name).Append("\"] = global::System.Convert.ToString(")
                          .Append(p.Name).Append("); }").AppendLine();
                    }
                }
            }
            sb.AppendLine("        object? __argsObj = __argsDict;");
        }
        else
        {
            sb.AppendLine("        object? __argsObj = null;");
        }

        sb.AppendLine("        var __logMethod = \"" + typeFullName + "\" + \"." + methodName + "\";");
        sb.AppendLine("        var __logger = (__sp?.GetService(typeof(global::Microsoft.Extensions.Logging.ILoggerFactory)) as global::Microsoft.Extensions.Logging.ILoggerFactory)?.CreateLogger(\"SourceGenerator.Runtime.ProxyRuntime\");");

        var hasByRef2 = isByRefReturn || method.Parameters.Any(p => p.RefKind != RefKind.None || p.Type.IsRefLikeType);
        var behaviorSnippets = new List<string> { "new global::SourceGenerator.Runtime.Pipeline.Behaviors.LoggingBehavior()" };
        var optionsSetters = new List<string>();
        foreach (var a in method.GetAttributes())
        {
            if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
            {
                var include = !hasByRef2 || CanUseAsFilter(a);
                if (include)
                {
                    behaviorSnippets.Add($"new {behaviorFull}()");
                    if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                }
            }
        }
        if (impl is not null)
        {
            foreach (var a in impl.GetAttributes())
            {
                if (TryGetBehaviorSpec(a, out var behaviorFull, out var optInit))
                {
                    var include = !hasByRef2 || CanUseAsFilter(a);
                    if (include)
                    {
                        behaviorSnippets.Add($"new {behaviorFull}()");
                        if (!string.IsNullOrEmpty(optInit)) optionsSetters.Add(optInit!);
                    }
                }
            }
        }
        sb.AppendLine("        var __behaviors = new global::SourceGenerator.Runtime.Pipeline.IInvocationAsyncBehavior[] { " + string.Join(", ", behaviorSnippets) + " };");
        var __hasReturn = isGenericTask || isGenericValueTask || (!isTask && !isValueTask && !method.ReturnsVoid) || isAsyncEnumerable;
        var __allowRet = __hasReturn && IsAllowReturnSerialization(method);
        sb.AppendLine("        var __ctx = new global::SourceGenerator.Runtime.Pipeline.InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = global::System.Guid.CreateVersion7(), Log = true, HasReturnValue = " + (__hasReturn ? "true" : "false") + ", AllowReturnSerialization = " + (__allowRet ? "true" : "false") + ", ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
        if (optionsSetters.Count > 0) sb.AppendLine("        " + string.Join("\n        ", optionsSetters));

        var call = "base." + methodName + typeParams + "(" + argList + ")";
        if (hasByRef2 || isAsyncEnumerable || isTaskOfAsyncEnumerable || isValueTaskOfAsyncEnumerable)
        {
            sb.AppendLine("        var __filters = new global::System.Collections.Generic.List<global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior>();");
            sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior __f) __filters.Add(__f); }");
            if (isAsyncEnumerable)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                var callExpr2 = "base." + methodName + typeParams + "(" + argList + ")";
                sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __e = {callExpr2}.GetAsyncEnumerator();");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                while (true)");
                sb.AppendLine("                {");
                sb.AppendLine("                    bool __moved;");
                sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("                    if (!__moved) break;");
                sb.AppendLine("                    var __item = __e.Current;");
                sb.AppendLine("                    try { __items.Add(global::SourceGenerator.Runtime.JsonUtil.ToObject(global::SourceGenerator.Runtime.JsonUtil.ToJson(__item))); } catch { __items.Add(global::System.Convert.ToString(__item)); }");
                sb.AppendLine("                    yield return __item;");
                sb.AppendLine("                }");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                await __e.DisposeAsync();");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine($"        return __streamWrapper();");
                sb.AppendLine("    }");
                return;
            }
            if (isTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            await {call};");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isTaskOfAsyncEnumerable)
            {
                var tItem = (((INamedTypeSymbol)((INamedTypeSymbol)method.ReturnType).TypeArguments[0]).TypeArguments[0])
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tItem}> __streamWrapper(){{");
                sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __s = await {call};");
                sb.AppendLine("            var __e = __s.GetAsyncEnumerator();");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                while (true)");
                sb.AppendLine("                {");
                sb.AppendLine("                    bool __moved;");
                sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("                    if (!__moved) break;");
                sb.AppendLine("                    var __item = __e.Current;");
                sb.AppendLine("                    try { __items.Add(global::SourceGenerator.Runtime.JsonUtil.ToObject(global::SourceGenerator.Runtime.JsonUtil.ToJson(__item))); } catch { __items.Add(global::System.Convert.ToString(__item)); }");
                sb.AppendLine("                    yield return __item;");
                sb.AppendLine("                }");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                await __e.DisposeAsync();");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine($"        return global::System.Threading.Tasks.Task.FromResult<global::System.Collections.Generic.IAsyncEnumerable<{tItem}>>(__streamWrapper());");
            }
            else if (isGenericTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __res = await {call};");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                sb.AppendLine("            return __res;");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isValueTaskOfAsyncEnumerable)
            {
                var tItem = (((INamedTypeSymbol)((INamedTypeSymbol)method.ReturnType).TypeArguments[0]).TypeArguments[0])
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tItem}> __streamWrapper(){{");
                sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __s = await {call};");
                sb.AppendLine("            var __e = __s.GetAsyncEnumerator();");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine("                while (true)");
                sb.AppendLine("                {");
                sb.AppendLine("                    bool __moved;");
                sb.AppendLine("                    try { __moved = await __e.MoveNextAsync(); } catch (global::System.Exception __ex) { foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("                    if (!__moved) break;");
                sb.AppendLine("                    var __item = __e.Current;");
                sb.AppendLine("                    try { __items.Add(global::SourceGenerator.Runtime.JsonUtil.ToObject(global::SourceGenerator.Runtime.JsonUtil.ToJson(__item))); } catch { __items.Add(global::System.Convert.ToString(__item)); }");
                sb.AppendLine("                    yield return __item;");
                sb.AppendLine("                }");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                sb.AppendLine("            }");
                sb.AppendLine("            finally");
                sb.AppendLine("            {");
                sb.AppendLine("                await __e.DisposeAsync();");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask<global::System.Collections.Generic.IAsyncEnumerable<{tItem}>>(__streamWrapper());");
            }
            else if (isValueTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            await {call};");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, null);");
                sb.AppendLine("            return;");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isGenericValueTask)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try");
                sb.AppendLine("        {");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine($"            var __res = await {call};");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnAfter(__ctx, __res);");
                sb.AppendLine("            return __res;");
                sb.AppendLine("        }");
                sb.AppendLine("        catch (global::System.Exception __ex)");
                sb.AppendLine("        {");
                if (!string.IsNullOrEmpty(updateSnippet)) sb.AppendLine("            " + updateSnippet);
                sb.AppendLine("            foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("            throw;");
                sb.AppendLine("        }");
            }
            else if (isByRefReturn)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); ref var __ret = ref " + call + "; var __snap = __ret; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __snap); return ref __ret; } catch (global::System.Exception __ex) { " + updateSnippet + " foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
            }
            else if (method.ReturnsVoid)
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); " + call + "; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, null); } catch (global::System.Exception __ex) { " + updateSnippet + " foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
                sb.AppendLine("        return;");
            }
            else
            {
                var updateSnippet = BuildArgsUpdateSnippet(method);
                sb.AppendLine("        try { foreach (var __f in __filters) __f.OnBefore(__ctx); var __ret = " + call + "; " + updateSnippet + " foreach (var __f in __filters) __f.OnAfter(__ctx, __ret); return __ret; } catch (global::System.Exception __ex) { " + updateSnippet + " foreach (var __f in __filters) __f.OnException(__ctx, __ex); throw; }");
            }
        }
        else
        {
            if (isAsyncEnumerable)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                var callExpr3 = "base." + methodName + typeParams + "(" + argList + ")";
                sb.AppendLine("        var __behaviors = new global::SourceGenerator.Runtime.Pipeline.IInvocationAsyncBehavior[] { new global::SourceGenerator.Runtime.Pipeline.Behaviors.LoggingBehavior() };")
                  .AppendLine("        var __ctx = new global::SourceGenerator.Runtime.Pipeline.InvocationContext { Method = __logMethod, Args = __argsObj, TraceId = global::System.Guid.CreateVersion7(), Log = true, HasReturnValue = true, AllowReturnSerialization = true, ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
                sb.AppendLine("        var __filters = new global::System.Collections.Generic.List<global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior>();");
                sb.AppendLine("        foreach (var __b in __behaviors) { if (__b is global::SourceGenerator.Runtime.Pipeline.IInvocationBehavior __f) __filters.Add(__f); }");
                sb.AppendLine($"        async global::System.Collections.Generic.IAsyncEnumerable<{tArg}> __streamWrapper(){{");
                sb.AppendLine("            var __items = new global::System.Collections.Generic.List<object?>(16);");
                sb.AppendLine("            foreach (var __f in __filters) __f.OnBefore(__ctx);");
                sb.AppendLine("            try");
                sb.AppendLine("            {");
                sb.AppendLine($"                await foreach (var __item in {callExpr3})");
                sb.AppendLine("                {");
                sb.AppendLine("                    try { __items.Add(global::SourceGenerator.Runtime.JsonUtil.ToObject(global::SourceGenerator.Runtime.JsonUtil.ToJson(__item))); } catch { __items.Add(global::System.Convert.ToString(__item)); }");
                sb.AppendLine("                    yield return __item;");
                sb.AppendLine("                }");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnAfter(__ctx, __items);");
                sb.AppendLine("            }");
                sb.AppendLine("            catch (global::System.Exception __ex)");
                sb.AppendLine("            {");
                sb.AppendLine("                foreach (var __f in __filters) __f.OnException(__ctx, __ex);");
                sb.AppendLine("                throw;");
                sb.AppendLine("            }");
                sb.AppendLine("        }");
                sb.AppendLine($"        return __streamWrapper();");
                sb.AppendLine("    }");
                return;
            }

            var runtime = "global::SourceGenerator.Runtime.ProxyRuntime";
            if (isTask)
            {
                sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
            }
            else if (isGenericTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {call});");
            }
            else if (isValueTask)
            {
                sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
            }
            else if (isGenericValueTask)
            {
                var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                    .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
                sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => {call} );");
            }
            else if (method.ReturnsVoid)
            {
                sb.AppendLine($"        {runtime}.Execute<object?>(__ctx, () => {{ {call}; return global::System.Threading.Tasks.ValueTask.FromResult<object?>(null); }});");
                sb.AppendLine("        return;");
            }
            else
            {
                // Fallback guard: if compile-time detection missed Task/Task<T>, switch based on returnType text
                if (returnType.StartsWith("global::System.Threading.Tasks.Task<", StringComparison.Ordinal))
                {
                    var tArgText = returnType.Substring("global::System.Threading.Tasks.Task<".Length);
                    tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {call});");
                }
                else if (string.Equals(returnType, "global::System.Threading.Tasks.Task", StringComparison.Ordinal))
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
                }
                // Fallback guard: if compile-time detection missed ValueTask/ValueTask<T>, switch based on returnType text
                else if (returnType.StartsWith("global::System.Threading.Tasks.ValueTask<", StringComparison.Ordinal))
                {
                    var tArgText = returnType.Substring("global::System.Threading.Tasks.ValueTask<".Length);
                    tArgText = tArgText.EndsWith(">", StringComparison.Ordinal) ? tArgText.Substring(0, tArgText.Length - 1) : tArgText;
                    sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArgText}>(__ctx, () => {call} );");
                }
                else if (string.Equals(returnType, "global::System.Threading.Tasks.ValueTask", StringComparison.Ordinal))
                {
                    sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => {call});");
                }
                else
                {
                    sb.AppendLine($"        return {runtime}.Execute<{returnType}>(__ctx, () => global::System.Threading.Tasks.ValueTask.FromResult({call}));");
                }
            }
        }

        sb.AppendLine("    }");
    }

    private static void AppendExplicitInterfaceProperty(StringBuilder sb, INamedTypeSymbol iface, IPropertySymbol prop, INamedTypeSymbol cls)
    {
        var typeName = prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var ifaceDisplay = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        sb.Append("    ").Append(typeName).Append(' ').Append(ifaceDisplay).Append('.').Append(prop.Name).AppendLine()
          .AppendLine("    {");
        if (prop.GetMethod is not null)
        {
            sb.AppendLine("        get => base." + prop.Name + ";");
        }
        if (prop.SetMethod is not null)
        {
            sb.AppendLine("        set => base." + prop.Name + " = value;");
        }
        sb.AppendLine("    }");
    }

    private static void AppendExplicitInterfaceEvent(StringBuilder sb, INamedTypeSymbol iface, IEventSymbol ev, INamedTypeSymbol cls)
    {
        var typeName = ev.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        var ifaceDisplay = iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        sb.Append("    event ").Append(typeName).Append(' ').Append(ifaceDisplay).Append('.').Append(ev.Name).AppendLine()
          .AppendLine("    {")
          .AppendLine("        add => base." + ev.Name + " += value;")
          .AppendLine("        remove => base." + ev.Name + " -= value;")
          .AppendLine("    }");
    }

    private static bool TryGetBehaviorSpec(AttributeData a, out string behaviorFull, out string? optSetter)
    {
        behaviorFull = string.Empty;
        optSetter = null;
        var attrClass = a.AttributeClass as INamedTypeSymbol;
        if (attrClass is null) return false;
        INamedTypeSymbol? proxyBase = null;
        for (var t = attrClass; t is not null; t = t.BaseType as INamedTypeSymbol)
        {
            var constructed = t.ConstructedFrom ?? t;
            if (constructed is INamedTypeSymbol nt && IsNamedType(nt, "SourceGenerator.Runtime.Attributes", "ProxyBehaviorAttribute"))
            {
                proxyBase = t; // keep the concrete generic base to read TypeArguments
                break;
            }
        }
        if (proxyBase is null) return false;
        ITypeSymbol? behaviorTypeSymbol = null;
        INamedTypeSymbol? optionsTypeSymbol = null;
        if (proxyBase.IsGenericType)
        {
            if (proxyBase.TypeArguments.Length == 1)
            {
                behaviorTypeSymbol = proxyBase.TypeArguments[0];
            }
            else if (proxyBase.TypeArguments.Length == 2)
            {
                behaviorTypeSymbol = proxyBase.TypeArguments[0];
                optionsTypeSymbol = proxyBase.TypeArguments[1] as INamedTypeSymbol;
            }
        }
        if (behaviorTypeSymbol is null) return false;
        behaviorFull = behaviorTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (optionsTypeSymbol is not null)
        {
            var assigns = new List<string>();
            foreach (var kv in a.NamedArguments)
            {
                var propName = kv.Key;
                var prop = optionsTypeSymbol.GetMembers().OfType<IPropertySymbol>().FirstOrDefault(p => p.Name == propName && !p.IsReadOnly);
                if (prop is null) continue;
                var lit = ToCSharpLiteral(kv.Value);
                if (lit is null) continue;
                assigns.Add(propName + " = " + lit);
            }
            var optFull = optionsTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var init = assigns.Count > 0 ? " { " + string.Join(", ", assigns) + " }" : string.Empty;
            optSetter = $"__ctx.SetFeature(new {optFull}{init});";
        }
        return true;
    }

    private static bool CanUseAsFilter(AttributeData a)
    {
        // Try to determine if the behavior type implements IInvocationBehavior (sync filter) so it can participate in by-ref sync path
        var attrClass = a.AttributeClass as INamedTypeSymbol;
        if (attrClass is null) return false;
        INamedTypeSymbol? proxyBase = null;
        for (var t = attrClass; t is not null; t = t.BaseType as INamedTypeSymbol)
        {
            var constructed = t.ConstructedFrom ?? t;
            if (constructed is INamedTypeSymbol nt && IsNamedType(nt, "SourceGenerator.Runtime.Attributes", "ProxyBehaviorAttribute"))
            {
                proxyBase = t;
                break;
            }
        }
        if (proxyBase is null) return false;
        ITypeSymbol? behaviorTypeSymbol = null;
        if (proxyBase.IsGenericType && proxyBase.TypeArguments.Length >= 1)
        {
            behaviorTypeSymbol = proxyBase.TypeArguments[0];
        }
        if (behaviorTypeSymbol is INamedTypeSymbol nts)
        {
            foreach (var itf in nts.AllInterfaces)
            {
                if (IsType(itf, "SourceGenerator.Runtime.Pipeline.IInvocationBehavior")) return true;
            }
        }
        return false;
    }

    private static string FormatParameter(IParameterSymbol p, bool includeDefault)
    {
        var type = p.Type
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var mod = p.RefKind == RefKind.Ref ? "ref " : p.RefKind == RefKind.Out ? "out " : p.RefKind == RefKind.In ? "in " : string.Empty;
        // Preserve DI-relevant parameter attributes (e.g., FromKeyedServices/FromServices)
        var attrPrefix = BuildParameterAttributesPrefix(p);
        string @default = string.Empty;
        if (includeDefault && p.HasExplicitDefaultValue)
        {
            if (p.ExplicitDefaultValue is null)
            {
                @default = p.Type.IsReferenceType ? " = null" : " = default";
            }
            else if (p.ExplicitDefaultValue is string s)
            {
                @default = " = \"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"";
            }
            else if (p.ExplicitDefaultValue is bool b)
            {
                @default = b ? " = true" : " = false";
            }
            else if (p.ExplicitDefaultValue is char ch)
            {
                var esc = ch == '\'' ? "\\'" : ch.ToString();
                @default = " = '" + esc + "'";
            }
            else if (p.ExplicitDefaultValue is IFormattable f)
            {
                @default = " = " + f.ToString(null, System.Globalization.CultureInfo.InvariantCulture);
            }
            else
            {
                @default = " = " + p.ExplicitDefaultValue.ToString();
            }
        }
        return attrPrefix + mod + type + " " + p.Name + @default;
    }

    private static string BuildParameterAttributesPrefix(IParameterSymbol p)
    {
        if (p is null) return string.Empty;
        var attrs = p.GetAttributes();
        if (attrs.Length == 0) return string.Empty;

        var sb = new StringBuilder();
        foreach (var attr in attrs)
        {
            if (attr.AttributeClass is not INamedTypeSymbol at) continue;
            // Only forward DI-binding related attributes that affect parameter resolution
            //  - Microsoft.Extensions.DependencyInjection.FromKeyedServicesAttribute(object key)
            //  - Microsoft.Extensions.DependencyInjection.FromServicesAttribute()
            if (IsNamedType(at, "Microsoft.Extensions.DependencyInjection", "FromKeyedServicesAttribute"))
            {
                // Single ctor arg: the key (object?)
                var keyText = FormatTypedConstant(attr.ConstructorArguments.FirstOrDefault());
                sb.Append("[global::Microsoft.Extensions.DependencyInjection.FromKeyedServices(")
                  .Append(keyText)
                  .Append(")] ");
                // We'll append as raw later; for now continue
            }
            else if (IsNamedType(at, "Microsoft.Extensions.DependencyInjection", "FromServicesAttribute"))
            {
                sb.Append("[global::Microsoft.Extensions.DependencyInjection.FromServices] ");
            }
        }

        var result = sb.ToString();
        return result;
    }

    private static string FormatTypedConstant(TypedConstant constant)
    {
        if (constant.IsNull) return "null";
        try
        {
            var v = constant.Value;
            if (v is null) return "null";
            // Preserve enum constants as fully-qualified Enum.Member when possible
            if (constant.Type is INamedTypeSymbol enumType && enumType.TypeKind == TypeKind.Enum)
            {
                var fqEnum = enumType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                var field = enumType.GetMembers()
                    .OfType<IFieldSymbol>()
                    .FirstOrDefault(f => f.HasConstantValue && Equals(f.ConstantValue, v));
                if (field is not null)
                {
                    return fqEnum + "." + field.Name;
                }
                // Fallback: cast from numeric literal to enum type
                var numText = (v is IFormattable ff)
                    ? ff.ToString(null, System.Globalization.CultureInfo.InvariantCulture) ?? "0"
                    : v.ToString() ?? "0";
                return "(" + fqEnum + ")" + numText;
            }
            return v switch
            {
                string s => "\"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"",
                char ch => "'" + (ch == '\'' ? "\\'" : ch.ToString()) + "'",
                bool b => b ? "true" : "false",
                IFormattable f => f.ToString(null, System.Globalization.CultureInfo.InvariantCulture) ?? "null",
                _ => v.ToString() ?? "null"
            };
        }
        catch
        {
            // Fallback to a neutral representation
            return "null";
        }
    }

    private static bool IsType(ITypeSymbol t, string metadataName)
    {
        // Compare fully-qualified names for exact match; handle generic by comparing the unconstructed definition
        if (t is INamedTypeSymbol nt)
        {
            var open = nt.IsGenericType && nt.ConstructedFrom is INamedTypeSymbol cf ? cf : nt;
            var fq = open.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var expected = metadataName.StartsWith("global::", StringComparison.Ordinal)
                ? metadataName
                : "global::" + metadataName;
            return string.Equals(fq, expected, StringComparison.Ordinal);
        }
        else
        {
            var fq = t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            var expected = metadataName.StartsWith("global::", StringComparison.Ordinal)
                ? metadataName
                : "global::" + metadataName;
            return string.Equals(fq, expected, StringComparison.Ordinal);
        }
    }

    private static bool IsNamedType(INamedTypeSymbol symbol, string @namespace, string name, int? arity = null)
    {
        var ns = GetFullNamespace(symbol.ContainingNamespace);
        if (!string.Equals(ns, @namespace, StringComparison.Ordinal)) return false;
        if (!string.Equals(symbol.Name, name, StringComparison.Ordinal)) return false;
        if (arity.HasValue && symbol.Arity != arity.Value) return false;
        return true;
    }

    // Decide at compile-time whether a parameter type should be skipped from JSON serialization and replaced with a placeholder
    private static bool TryGetSkipPlaceholder(ITypeSymbol type, out string placeholder)
    {
        placeholder = "<skipped>";

        // Cancellation
        if (IsType(type, "System.Threading.CancellationToken")) { placeholder = "<cancellation-token>"; return true; }
        if (IsType(type, "System.Threading.CancellationTokenSource")) { placeholder = "<cancellation-token-source>"; return true; }

        // Delegates
        if (type.TypeKind == TypeKind.Delegate) { placeholder = "<delegate>"; return true; }

        // Streams / Readers / Writers
        if (IsOrDerivedFrom(type, "System.IO.Stream")) { placeholder = "<stream>"; return true; }
        if (IsOrDerivedFrom(type, "System.IO.TextReader")) { placeholder = "<text-reader>"; return true; }
        if (IsOrDerivedFrom(type, "System.IO.TextWriter")) { placeholder = "<text-writer>"; return true; }

        // Pipelines
        if (IsType(type, "System.IO.Pipelines.PipeReader")) { placeholder = "<pipe-reader>"; return true; }
        if (IsType(type, "System.IO.Pipelines.PipeWriter")) { placeholder = "<pipe-writer>"; return true; }

        // Channels (generic definitions)
        if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelReader", 1)) { placeholder = "<channel-reader>"; return true; }
        if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelWriter", 1)) { placeholder = "<channel-writer>"; return true; }

        // ASP.NET Core Http*
        var ns = GetFullNamespace(type.ContainingNamespace);
        if (ns.StartsWith("Microsoft.AspNetCore.Http", StringComparison.Ordinal)) { placeholder = "<http-context>"; return true; }

        // Security principals
        if (IsType(type, "System.Security.Claims.ClaimsPrincipal") || ImplementsInterface(type, "System.Security.Principal.IPrincipal"))
        { placeholder = "<principal>"; return true; }

        // DI / Logging
        if (ImplementsInterface(type, "System.IServiceProvider")) { placeholder = "<service-provider>"; return true; }
        if (ImplementsInterfaceNamed(type, "Microsoft.Extensions.Logging", "ILogger")) { placeholder = "<logger>"; return true; }

        // Database
        if (IsOrDerivedFrom(type, "System.Data.Common.DbConnection") || ImplementsInterface(type, "System.Data.IDbConnection"))
        { placeholder = "<db-connection>"; return true; }
        if (IsOrDerivedFrom(type, "System.Data.Common.DbTransaction")) { placeholder = "<db-transaction>"; return true; }
        if (IsOrDerivedFrom(type, "System.Data.Common.DbCommand")) { placeholder = "<db-command>"; return true; }

        // HTTP
        if (IsType(type, "System.Net.Http.HttpClient")) { placeholder = "<http-client>"; return true; }
        if (IsType(type, "System.Net.Http.HttpRequestMessage")) { placeholder = "<http-request>"; return true; }
        if (IsType(type, "System.Net.Http.HttpResponseMessage")) { placeholder = "<http-response>"; return true; }

        // Expressions
        if (IsOrDerivedFrom(type, "System.Linq.Expressions.Expression")) { placeholder = "<expression>"; return true; }

        return false;
    }

    private static bool IsOrDerivedFrom(ITypeSymbol type, string metadataName)
    {
        for (var t = type; t is not null; t = t.BaseType)
        {
            if (IsType(t, metadataName)) return true;
        }
        return false;
    }

    private static bool IsOrDerivedFromGeneric(ITypeSymbol type, string @namespace, string name, int arity)
    {
        for (var t = type; t is not null; t = t.BaseType)
        {
            if (t is INamedTypeSymbol nt && nt.IsGenericType && IsNamedType(nt.ConstructedFrom, @namespace, name, arity))
                return true;
        }
        return false;
    }

    private static bool ImplementsInterface(ITypeSymbol type, string metadataName)
    {
        foreach (var i in type.AllInterfaces)
        {
            if (IsType(i, metadataName)) return true;
        }
        return false;
    }

    private static bool ImplementsInterfaceNamed(ITypeSymbol type, string @namespace, string name, int? arity = null)
    {
        foreach (var i in type.AllInterfaces)
        {
            if (i is INamedTypeSymbol nt && IsNamedType(nt, @namespace, name, arity)) return true;
        }
        return false;
    }

    private static bool IsAllowReturnSerialization(IMethodSymbol method)
    {
        var rt = method.ReturnType;
        // Async streams: logged as placeholder, considered loggable
        if ((rt is INamedTypeSymbol nts4 && nts4.IsGenericType && IsType(nts4.ConstructedFrom, "System.Collections.Generic.IAsyncEnumerable"))
            || rt.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).StartsWith("global::System.Collections.Generic.IAsyncEnumerable<", StringComparison.Ordinal))
            return true;

        // Task / ValueTask with no result
        if (rt is INamedTypeSymbol ntsTask && !ntsTask.IsGenericType && IsType(ntsTask, "System.Threading.Tasks.Task"))
            return false;
        if (rt is INamedTypeSymbol ntsVt && !ntsVt.IsGenericType && IsType(ntsVt, "System.Threading.Tasks.ValueTask"))
            return false;

        // Unwrap Task<T> / ValueTask<T>
        if (rt is INamedTypeSymbol ntsG && ntsG.IsGenericType)
        {
            if (IsType(ntsG.ConstructedFrom, "System.Threading.Tasks.Task") || IsType(ntsG.ConstructedFrom, "System.Threading.Tasks.ValueTask"))
            {
                var tArg = ntsG.TypeArguments[0];
                return IsReturnTypeLoggableCore(tArg);
            }
        }

        if (method.ReturnsVoid) return false;
        return IsReturnTypeLoggableCore(rt);
    }

    private static bool IsReturnTypeLoggableCore(ITypeSymbol type)
    {
        if (IsOrDerivedFrom(type, "System.IO.Stream")) return false;
        if (IsOrDerivedFrom(type, "System.IO.TextReader")) return false;
        if (IsOrDerivedFrom(type, "System.IO.TextWriter")) return false;
        if (IsType(type, "System.IO.Pipelines.PipeReader")) return false;
        if (IsType(type, "System.IO.Pipelines.PipeWriter")) return false;
        if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelReader", 1)) return false;
        if (IsOrDerivedFromGeneric(type, "System.Threading.Channels", "ChannelWriter", 1)) return false;
        if (IsOrDerivedFrom(type, "System.Data.Common.DbConnection") || ImplementsInterface(type, "System.Data.IDbConnection")) return false;
        if (IsOrDerivedFrom(type, "System.Data.Common.DbTransaction")) return false;
        if (IsOrDerivedFrom(type, "System.Data.Common.DbCommand")) return false;
        if (IsType(type, "System.Net.Http.HttpRequestMessage")) return false;
        if (IsType(type, "System.Net.Http.HttpResponseMessage")) return false;
        if (IsType(type, "System.Net.Http.HttpClient")) return false;
        if (type.TypeKind == TypeKind.Delegate) return false;
        if (IsOrDerivedFrom(type, "System.Linq.Expressions.Expression")) return false;
        if (IsType(type, "System.Security.Claims.ClaimsPrincipal") || ImplementsInterface(type, "System.Security.Principal.IPrincipal")) return false;
        return true;
    }
    private static string GetFullNamespace(INamespaceSymbol ns)
    {
        if (ns == null || ns.IsGlobalNamespace) return string.Empty;
        var stack = new Stack<string>();
        for (var n = ns; n is not null && !n.IsGlobalNamespace; n = n.ContainingNamespace)
        {
            stack.Push(n.Name);
        }
        return string.Join(".", stack);
    }

    private static string BuildArgsUpdateSnippet(IMethodSymbol method)
    {
        var updates = new List<string>();
        foreach (var p in method.Parameters)
        {
            if (p.RefKind != RefKind.None)
            {
                // Refresh ref/out/in values in the args dict after call
                if (TryGetSkipPlaceholder(p.Type, out var ph))
                {
                    var escaped = ph.Replace("\\", "\\\\").Replace("\"", "\\\"");
                    updates.Add($"__argsDict[\"{p.Name}\"] = \"{escaped}\";");
                }
                else
                {
                    updates.Add($"try {{ __argsDict[\"{p.Name}\"] = global::SourceGenerator.Runtime.JsonUtil.ToJson({p.Name}); }} catch {{ __argsDict[\"{p.Name}\"] = global::System.Convert.ToString({p.Name}); }}");
                }
            }
        }
        return updates.Count == 0 ? string.Empty : string.Join(" ", updates);
    }

    private static string BuildTypeParametersDecl(INamedTypeSymbol cls)
    {
        // Hoist ALL outer + inner type parameters to the proxy class declaration
        var allTps = GetAllTypeParameters(cls);
        if (allTps.Count == 0) return string.Empty;
        return "<" + string.Join(", ", allTps.Select(tp => tp.Name)) + ">";
    }

    private static string BuildTypeParameterConstraints(INamedTypeSymbol cls)
    {
        // Apply constraints for ALL hoisted type parameters (including outer types)
        var allTps = GetAllTypeParameters(cls);
        if (allTps.Count == 0) return string.Empty;
        var sb = new StringBuilder();
        foreach (var tp in allTps)
        {
            var parts = new List<string>();
            // Primary constraints first
            if (tp.HasReferenceTypeConstraint) parts.Add("class");
            if (tp.HasUnmanagedTypeConstraint) parts.Add("unmanaged");
            if (tp.HasValueTypeConstraint) parts.Add("struct");
            if (tp.HasNotNullConstraint) parts.Add("notnull");
            // Specific type/interface constraints
            foreach (var ct in tp.ConstraintTypes)
            {
                parts.Add(ct.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
            }
            // new() last
            if (tp.HasConstructorConstraint) parts.Add("new()");
            if (parts.Count > 0)
            {
                sb.Append("    where ").Append(tp.Name).Append(" : ").Append(string.Join(", ", parts)).AppendLine();
            }
        }
        return sb.ToString();
    }

    private static string? ToCSharpLiteral(TypedConstant c)
    {
        if (c.IsNull) return "null";
        if (c.Value is null) return null;
        if (c.Value is string s) return "\"" + s.Replace("\\", "\\\\").Replace("\"", "\\\"") + "\"";
        if (c.Value is bool b) return b ? "true" : "false";
        if (c.Value is char ch) return "'" + (ch == '\'' ? "\\'" : ch.ToString()) + "'";
        if (c.Type is INamedTypeSymbol nts && nts.TypeKind == TypeKind.Enum)
        {
            var named = nts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            return named + "." + c.Value.ToString();
        }
        if (c.Value is IFormattable f) return f.ToString(null, System.Globalization.CultureInfo.InvariantCulture);
        return c.Value?.ToString();
    }

    private static string GetSafeHintName(INamedTypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace ? "global" : type.ContainingNamespace.ToDisplayString().Replace('.', '_');
        // Include containing type chain with generic arity and parameter names; avoid special characters in hint
        var parts = new List<string>();
        for (var t = type; t is not null; t = t.ContainingType)
        {
            var arity = t.TypeParameters.Length;
            var tpNames = arity > 0 ? "_" + string.Join("_", t.TypeParameters.Select(tp => tp.Name)) : string.Empty;
            var safeName = new string(t.Name.Select(ch => char.IsLetterOrDigit(ch) ? ch : '_').ToArray());
            var name = safeName + (arity > 0 ? "_g" + arity + tpNames : string.Empty);
            parts.Add(name);
        }
        parts.Reverse();
        return ns + "__" + string.Join("_", parts) + "__Proxy";
    }

    private static List<ITypeParameterSymbol> GetAllTypeParameters(INamedTypeSymbol type)
    {
        // Collect type parameters from outermost to innermost containing type
        var stack = new Stack<INamedTypeSymbol>();
        for (var t = type; t is not null; t = t.ContainingType)
            stack.Push(t);
        var list = new List<ITypeParameterSymbol>();
        foreach (var t in stack)
            list.AddRange(t.TypeParameters);
        return list;
    }

    private static string[] GetInterfacesNeedingExplicitImplementations(INamedTypeSymbol cls)
    {
        var set = new HashSet<string>();
        foreach (var iface in cls.AllInterfaces)
        {
            foreach (var member in iface.GetMembers())
            {
                switch (member)
                {
                    case IMethodSymbol m:
                        if (m.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise)
                            continue;
                        var implM = cls.FindImplementationForInterfaceMember(m) as IMethodSymbol;
                        if (implM is not null && implM.ExplicitInterfaceImplementations.Length > 0) continue;
                        if (implM is not null && (implM.IsVirtual || implM.IsAbstract || implM.IsOverride)) continue;
                        set.Add(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                        break;
                    case IPropertySymbol p:
                        var implP = cls.FindImplementationForInterfaceMember(p) as IPropertySymbol;
                        if (implP is not null && implP.ExplicitInterfaceImplementations.Length > 0) continue;
                        if (implP is not null)
                        {
                            var gm = implP.GetMethod; var sm = implP.SetMethod;
                            if ((gm is not null && (gm.IsVirtual || gm.IsAbstract || gm.IsOverride)) ||
                                (sm is not null && (sm.IsVirtual || sm.IsAbstract || sm.IsOverride)))
                                break;
                        }
                        set.Add(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                        break;
                    case IEventSymbol e:
                        var implE = cls.FindImplementationForInterfaceMember(e) as IEventSymbol;
                        if (implE is not null && implE.ExplicitInterfaceImplementations.Length > 0) continue;
                        if (implE is not null)
                        {
                            var am = implE.AddMethod; var rm = implE.RemoveMethod;
                            if ((am is not null && (am.IsVirtual || am.IsAbstract || am.IsOverride)) ||
                                (rm is not null && (rm.IsVirtual || rm.IsAbstract || rm.IsOverride)))
                                break;
                        }
                        set.Add(iface.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                        break;
                }
            }
        }
        return set.ToArray();
    }
}

