using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using SourceGenerator.Core.Internal;

namespace SourceGenerator.Core;

internal sealed class ClassProxyHandler
{
    private const string CacheableAttributeMetadataName = "SourceGenerator.Abstraction.Attributes.CacheableAttribute";
    private const string ProxyBehaviorAttributeMetadataName = "SourceGenerator.Abstraction.Attributes.ProxyBehaviorAttribute";

    public bool CanHandle(INamedTypeSymbol type, AttributeData? attribute)
        => type.TypeKind == TypeKind.Class;

    public void Execute(in HandlerContext ctx)
    {
        var src = GenerateClassProxy(ctx.Type);
        var hint = GetSafeHintName(ctx.Type) + ".g.cs";
        ctx.Context.AddSource(hint, src);
    }

    private static string GenerateClassProxy(INamedTypeSymbol cls)
    {
        var ns = cls.ContainingNamespace.IsGlobalNamespace
            ? "NetEngine.Generated"
            : cls.ContainingNamespace.ToDisplayString();

        var className = cls.Name;
        var ifaceName = "I" + className;
        var ifaceDisplay = ifaceName; // minimal qualified inside same namespace
        var proxyName = className + "_Proxy";

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.Append("namespace ").Append(ns).AppendLine(";");
        sb.AppendLine();

        // interface
        sb.Append("public interface ").Append(ifaceDisplay).AppendLine()
          .AppendLine("{");
        foreach (var m in cls.GetMembers().OfType<IMethodSymbol>())
        {
            if (!IsPublicInstance(m)) continue;
            if (m.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise or MethodKind.StaticConstructor or MethodKind.Constructor)
                continue;
            if (m.Parameters.Any(p => p.RefKind != RefKind.None)) continue;
            AppendInterfaceMethod(sig: sb, m);
        }
        sb.AppendLine("}");

        sb.AppendLine();

        // helpers
        sb.Append("file static class __ProxyHelpers_").Append(proxyName).AppendLine(" {");
        sb.AppendLine("    internal static string ArgToString(object? o)");
        sb.AppendLine("    {");
        sb.AppendLine("        return global::SourceGenerator.Runtime.JsonUtil.ToJson(o);");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();

        // proxy class
        sb.Append("public sealed class ").Append(proxyName).Append(" : ").Append(ifaceDisplay).AppendLine()
          .AppendLine("{")
          .Append("    private readonly ").Append(className).AppendLine(" __inner;")
          .AppendLine("    private readonly global::System.IServiceProvider? __sp;")
          .AppendLine()
          .Append("    public ").Append(proxyName).Append("(").Append(className).AppendLine(" inner)")
          .AppendLine("    {")
          .AppendLine("        __inner = inner ?? throw new global::System.ArgumentNullException(nameof(inner));")
          .AppendLine("    }")
          .AppendLine()
          .Append("    public ").Append(proxyName).Append("(").Append(className).AppendLine(" inner, global::System.IServiceProvider sp)")
          .AppendLine("    {")
          .AppendLine("        __inner = inner ?? throw new global::System.ArgumentNullException(nameof(inner));")
          .AppendLine("        __sp = sp;")
          .AppendLine("    }");

        foreach (var method in cls.GetMembers().OfType<IMethodSymbol>())
        {
            if (!IsPublicInstance(method)) continue;
            if (method.MethodKind is MethodKind.PropertyGet or MethodKind.PropertySet or MethodKind.EventAdd or MethodKind.EventRemove or MethodKind.EventRaise or MethodKind.StaticConstructor or MethodKind.Constructor)
                continue;
            AppendMethod(sb, method);
        }

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void AppendInterfaceMethod(StringBuilder sig, IMethodSymbol method)
    {
        var returnType = method.ReturnType
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var methodName = method.Name;
        var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
        var paramList = string.Join(", ", method.Parameters.Select(FormatParameter));
        sig.Append("    ").Append(returnType).Append(' ').Append(methodName).Append(typeParams)
           .Append('(').Append(paramList).AppendLine(");");
    }

    private static void AppendMethod(StringBuilder sb, IMethodSymbol method)
    {
        if (method.Parameters.Any(p => p.RefKind != RefKind.None)) return;

        var isGenericTask = method.ReturnType is INamedTypeSymbol nts && nts.IsGenericType && IsType(nts.ConstructedFrom, "System.Threading.Tasks.Task");
        var isTask = method.ReturnType is INamedTypeSymbol nts0 && !nts0.IsGenericType && IsType(nts0, "System.Threading.Tasks.Task");
        var isGenericValueTask = method.ReturnType is INamedTypeSymbol nts2 && nts2.IsGenericType && IsType(nts2.ConstructedFrom, "System.Threading.Tasks.ValueTask");
        var isValueTask = method.ReturnType is INamedTypeSymbol nts3 && !nts3.IsGenericType && IsType(nts3, "System.Threading.Tasks.ValueTask");

        var returnType = method.ReturnType
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var methodName = method.Name;
        var typeFullName = method.ContainingType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Replace("global::", string.Empty);
        var methodFullName = typeFullName + "." + methodName;
        var typeParams = method.TypeParameters.Length > 0 ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">" : string.Empty;
        var paramList = string.Join(", ", method.Parameters.Select(FormatParameter));
        var argList = string.Join(", ", method.Parameters.Select(p => p.Name));

        sb.Append("    public ").Append(returnType).Append(' ').Append(methodName).Append(typeParams)
          .Append('(').Append(paramList).Append(')').AppendLine()
          .AppendLine("    {");

        if (method.Parameters.Length > 0)
        {
            sb.AppendLine("        var __argsDict = new global::System.Collections.Generic.Dictionary<string, object?>(" + method.Parameters.Length + ");");
            foreach (var p in method.Parameters)
            {
                sb.Append("        __argsDict[\"").Append(p.Name).Append("\"] = ").Append(p.Name).AppendLine(";");
            }
            sb.AppendLine("        var __args = global::SourceGenerator.Runtime.JsonUtil.ToJson(__argsDict);");
        }
        else
        {
            sb.AppendLine("        string? __args = null;");
        }

        sb.AppendLine("        var __logMethod = (__inner.GetType().FullName ?? \"" + typeFullName + "\") + \"." + methodName + "\";");

        var cacheAttr = method.GetAttributes().FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == CacheableAttributeMetadataName);
        var hasCache = cacheAttr is not null && !method.ReturnsVoid;
        var ttl = 60;
        if (hasCache)
        {
            foreach (var kv in cacheAttr!.NamedArguments)
            {
                if (kv.Key == "TtlSeconds" && kv.Value.Value is int i) ttl = i;
            }
            sb.AppendLine("        var __cache = new global::SourceGenerator.Runtime.ProxyRuntime.CacheOptions { Seed = \"" + methodFullName + "\" + (__args is null ? string.Empty : __args), TtlSeconds = " + ttl + " };");
        }
        else
        {
            sb.AppendLine("        global::SourceGenerator.Runtime.ProxyRuntime.CacheOptions? __cache = null;");
        }

        sb.AppendLine("        var __logger = (__sp?.GetService(typeof(global::Microsoft.Extensions.Logging.ILoggerFactory)) as global::Microsoft.Extensions.Logging.ILoggerFactory)?.CreateLogger(\"SourceGenerator.Runtime.ProxyRuntime\");");

        var behaviorSnippets = new List<string> { "new global::SourceGenerator.Runtime.LoggingBehavior()" };
        foreach (var a in method.GetAttributes())
        {
            var attrClass = a.AttributeClass as INamedTypeSymbol;
            if (attrClass is null) continue;
            ITypeSymbol? behaviorTypeSymbol = null;
            for (var t = attrClass; t is not null; t = t.BaseType as INamedTypeSymbol)
            {
                var fullName = t.ConstructedFrom?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)
                               ?? t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (fullName.Contains(ProxyBehaviorAttributeMetadataName, StringComparison.Ordinal))
                {
                    if (t.IsGenericType && t.TypeArguments.Length == 1)
                    {
                        behaviorTypeSymbol = t.TypeArguments[0];
                    }
                    break;
                }
            }
            if (behaviorTypeSymbol is null) continue;
            var full = behaviorTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            behaviorSnippets.Add($"new {full}()");
        }
        sb.AppendLine("        var __behaviors = new global::SourceGenerator.Runtime.IInvocationBehavior[] { " + string.Join(", ", behaviorSnippets) + " };");
        sb.AppendLine("        var __ctx = new global::SourceGenerator.Runtime.InvocationContext { Method = __logMethod, ArgsJson = __args, TraceId = global::System.Guid.CreateVersion7(), Log = true, Measure = true, ServiceProvider = __sp, Logger = __logger, Behaviors = __behaviors };");
        sb.AppendLine("        if (__cache is not null) __ctx.SetFeature(__cache);");

        var runtime = "global::SourceGenerator.Runtime.ProxyRuntime";
        if (isTask)
        {
            sb.AppendLine($"        return {runtime}.ExecuteTask(__ctx, () => __inner.{methodName}{typeParams}({argList}));");
        }
        else if (isGenericTask)
        {
            var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            sb.AppendLine($"        return {runtime}.ExecuteAsync<{tArg}>(__ctx, () => new global::System.Threading.Tasks.ValueTask<{tArg}>( __inner.{methodName}{typeParams}({argList}) ) ).AsTask();");
        }
        else if (isValueTask)
        {
            sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask( {runtime}.ExecuteAsync<global::SourceGenerator.Runtime.Unit>(__ctx, () => __inner.{methodName}{typeParams}({argList}) ).AsTask() );");
        }
        else if (isGenericValueTask)
        {
            var tArg = ((INamedTypeSymbol)method.ReturnType).TypeArguments[0]
                .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
            sb.AppendLine($"        return new global::System.Threading.Tasks.ValueTask<{tArg}>( {runtime}.ExecuteAsync<{tArg}>(__ctx, () => __inner.{methodName}{typeParams}({argList}) ).AsTask() );");
        }
        else if (method.ReturnsVoid)
        {
            sb.AppendLine($"        {runtime}.Execute<global::SourceGenerator.Runtime.Unit>(__ctx, () => {{ __inner.{methodName}{typeParams}({argList}); return global::System.Threading.Tasks.ValueTask.FromResult(global::SourceGenerator.Runtime.Unit.Value); }});");
            sb.AppendLine("        return;");
        }
        else
        {
            sb.AppendLine($"        return {runtime}.Execute<{returnType}>(__ctx, () => global::System.Threading.Tasks.ValueTask.FromResult(__inner.{methodName}{typeParams}({argList})));");
        }

        sb.AppendLine("    }");
    }

    private static bool IsPublicInstance(IMethodSymbol m)
        => m.DeclaredAccessibility == Accessibility.Public && !m.IsStatic;

    private static string FormatParameter(IParameterSymbol p)
    {
        var type = p.Type
            .ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat.WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier));
        var @default = p.HasExplicitDefaultValue ? " = " + (p.ExplicitDefaultValue is null ? "null" : p.ExplicitDefaultValue is string s ? "\"" + s.Replace("\"", "\\\"") + "\"" : p.ExplicitDefaultValue.ToString()) : string.Empty;
        return type + " " + p.Name + @default;
    }

    private static bool IsType(ITypeSymbol t, string metadataName)
        => t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat).Contains(metadataName, StringComparison.Ordinal);

    private static string GetSafeHintName(INamedTypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace ? "global" : type.ContainingNamespace.ToDisplayString().Replace('.', '_');
        return ns + "__" + type.Name + "+Proxy";
    }
}
